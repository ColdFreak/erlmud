
    <p> The first three elements form the basis for the game itself and the second three form the basis for user interaction with that system. While the above is a nice early enumeration of the outer pieces we want to build, this tells us nothing about how they should be created, managed, found, communicated with, or really anything else about the system.</p>
    <p>In terms of an Erlang program this is actually OK. With just this limited definition we can begin to explore the problem space in more depth. First we will think through the basic problem of how to model everything as processes, and simply assume that this is a reasonable approach. Then we will consider the problem of how to initialize these processes and have them communicate. We will make these ideas concrete by writing some elementary wishful-thinking code that describes the ideas in more detail, and go as far as making some of that code actually work in some very limited way.</p>
    <p>I usually find it useful to begin modeling a system as if everything were a process, and not really worrying much about data structures until I have a reason to. If we abstract our data and communication methods properly, changing things like that in the background are typically not too much trouble. A surprising amount of the time any nagging performance worries we might have about having "too many" processes turn out to have been unfounded, or even contrary to high performance in a massively parallel environment. With more processes it is easier to scale "out" and not "up". This is an early part of removing bottlenecks by never creating any.</p>