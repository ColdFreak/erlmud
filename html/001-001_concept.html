<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" media="screen" />
  <link rel="stylesheet" type="text/css" href="erlmud_p.css" media="print" />
  <title>ErlMUD Notes: Concept | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="concepts">ErlMUD Concepts</h1>
    <p>Erlmud is a simple Multi-User Dungeon that runs over TCP.</p>
    <p>It is written in a way that takes advantage of Erlang's ability to model elements of a system as independent processes which communicate only by passing messages and dependent on the few promises provided by the Erlang runtime.</p>
    <h2 id="elements">Elements</h2>
    <p>In any project there are two categories of elements. There are those elements which obviously must be a part of the design, either because they represent a resource we know is required beforehand (a connection to a database, a socket handler, etc.) or because interacting with these elements is the purpose of the program (a representation of a record in a record editor, a set of users in a chat program, etc.). At the outset of the project this is what is seen. There are other elements, however, which we can only discover through a combination of analysis of the initially visible elements and making a few initial design decisions which will influence further design decisions which will have to be made during implementation. This is what is not seen.</p>
    <h3 id="seen">That which is seen</h3>
    <p>The primary elements we want to deal with in a MUD are:</p>
    <ul>
      <li>locations</li>
      <li>objects</li>
      <li>mobile entities</li>
    </ul>
    <p>A location is a space within which play can occur. Locations connect to other locations and travel is affected by having an entity leave one location as it enters another. The idea that locations must connect to one another to form a map, and that this map must make enough sense to players that it forms the basis for a playable world will inform our decisions about how to design a process that represents a location, what responsibilities a location might take on,
    and what (if any) accessory processes a location may require in the support of fulfilling its role.</p>
    <p>Objects are things which are not mobile or alive. Within this broad definition of objects we find anything else in the world that might not be alive but is also not a location: weapons, armor, consumables, light sources, money, clothing, food, containers, etc. The idea that some items may have a limited lifespan, and therefore have a way of being created and destroyed, picked up, placed within containers, act as containers, and maintain enough state to influence other elements of the game system tells us that the design of object processes is not entirely simple,
    and may not even fit within a single definition (a food object may need to be different from a weapon object,
    but adhere to a similar generic interface of "object").</p>
    <p> A mobile entity (aka "mob") is the real point of the game. Mobs are what do the verby things in MUDs. They are the world creatures, the NPCs, the player avatars, the predators and the prey. Without them the MUD would be a pretty boring place. Knowing that all the above types of characters and creatures which occur in MUDs are mobs indicates a few things. Namely, that while a general definition of mob may suffice, the controlling elements that make decisions for mobs may require a bit of diversification.</p>
    <p> The above three elements form the basis for the game itself, but this tells us nothing about how they should be created, managed, found within the game system, communicated with, or really anything else about the system.</p>
    <p> In terms of an Erlang program this is actually OK. With just this limited definition we can begin to explore the problem space in more depth first by thinking through the basic problem of how to initialize such a system of objects,
    and then by writing some elementary wishful-thinking code that describes the ideas in more detail.</p>
    <h4 id="locations">Locations</h4>
    <p>A location is a self-contained place within the game world where actions which immediately affect mobs take place. It is the physical limit of immediate physical interaction, the limit of object observability and availability, the initial aggression horizon, and generally defines the boundary of awareness and mob/mob, mob/object, mob/location and object/object interaction. Exceptions will arise, of course, but as a general concept locations will define the interaction boundary among other elements. (Examples of exceptions to this would be sending private messages to other players across the game world, global chat, a mail system, etc. -- if we decide to implement such a things.)</p>
    <p>In a C-style MUD world locations would be nothing more than elements within a data structure (some big indexed list or whatever), and the logic of determining a mob or object's location relative to another, fetching the location description, viewing the present contents of the location, attacking another player, verbal or emotive broadcasts to room occupants, etc. would be found in a small library of functions. The first argument to these functions would usually be pointers to the struct that represents the mob initiating the action (or no initiator if it was part of a global time event), the location, and from there the function would retreive matches for other occupants of the location and presents items and things from a constantly updated global data system (usually a large hash index of some sort).</p>
    <p>If the system were written in an OOP style the code would be nearly identical, but the initiating functions would usually be buried within the "objects" that represent the initiators (mostly mobs), and the arguments to those methods would eliminate the pointer to the initiator (being enclosed by the larger function that we call an object) and perform or initiate nearly the exact same process of global digest lookups to find other occupants, objects, etc. and perform whatever the action was.</p>
    <p>In this sort of system the heavy lifting is done by an array of functions acting upon a large number of data objects (whether structs or objects, it doesn't matter) and usually executed in sequence to prevent race conditions. Making a system such as this run fast enough to feel concurrent is not too hard, and partitioning the world so that the map is divided in such a way that activities involving entities in the same location occur within the same thread or process. The data itself is pretty much just that. The locations themselves have no responsibilities, don't <em>do</em> anything, and simply <em>are</em>. Even locations in OOP-styled systems are typically relegated to initializing their name, description, and exits when constructed, being assigned a variable or symbol name that sits in an indexed registry and then responding to "getter" queries about the little bits they know about themselves. Its actually more straight-forward to simply write a global location digest that handles the queries for the whole system instead of instantiating a thousand objects to represent the locations.</p>
    <p>It would be possible to create a system similar to this in Erlang, but it would not be a natural fit for the style of programming Erlang represents. In Erlang we have other processes to think about. Whereas "everything is an object" in a language like Python, in Erlang "everything is a process". What sort of things do locations do? For one thing, they contain other stuff. We know that they define the physical boundary of interaction among other elements of the game world, and we know that they should maintain a record of their entry and exit ways.</p>
    <p>While one could model a system this way in an OOP language, it is almost never actually done, partially for reasons of conceptual difficulty, and partially for reasons of early optimization in the minds of the developers. In most OOP languages we can fall back on quick and immediate access to global references, shared state, and other environmental elements presented in an environment of shared or single execution. In Erlang, however, this is not the case. There are no objects or global data references to be had. No state is shared among processes, and <em>everything is a separate process</em>. The only way a mob can know it is in a particular location is to either ask a global directory process where it is by sending it a message, asking a location its identity on entry and remembering it, or some other relatively indirect way of signaling to the world that it needs to know or already does know its location.</p>
    <p>This is where the role of locations really comes into play. Locations are the arbiters of physical activity and define the boundaries of interactivity. If a mob performs an action, it should be represented as a message to the present location, and that location must broadcast it to the other occupants or not, as the location itself is the only one that has a perfectly current idea what other elements are present just then. When a mob "says" something, it says it to the room, and the room broadcasts it to the other mobs. When a player drop an item, it sends a message to the present location that an item has been added. When a mob attacks another mob the attack initiation must pass through the location to the target to confirm that the combat situation is valid. When a mob attempts to exit in a particular direction, it is the room that must determine whether or not the way exists and is available just then</p>
    <p>Hmm. "Whether the way is available?" Let's think about that for a moment. A way between two locations is not such a simple thing. A way could be a door or a path. Doors can be shut, doors can be locked, and adjacent locations, being processes written by our imperfect fingers running on imperfect hardware, may be down for some reason. So a way is not so simple. This requires considerable thought. Let us tuck this into the back of our minds for now, knowing that we will have to deal with the not-so-trivial concept of ways between locations later on.</p>
    <h4 id="objects">Objects</h4>
    <p>Here we do not mean "objects" as in higher order functions that know how to dispatch, or structs that have better syntax for calling functions they contain pointers to, or whatever. Here I mean "game world things". A torch, a bit of grass, a delicious cheeseburger, a weapon, a pair of pink pants, etc. These are the objects of the game world. It is obvious that different object types exist, and that different rules must exist for different object interactions, at least to some degree. How should this be modeled?</p>
    <p>In a C-style game system objects are usually just structs that contain current information and a pointer to static, definition type information. So if the game system permits weapons to have declining durability, for example, the struct representing the weapon would maintain a record of its current "health" status, and a pointer to things like its max health, its effectiveness, offensive bonus, weight, and whatever else about it that might be significant but unchanged by its health status. Within this static information would be a record of its class type, usually something like an enum <code>{weapon, shield, armor, food, drink, ...}</code> and this would be checked against a list of permitted actions to enable the eating of a ham, but prevent wearing a ham as a helmet or wielding a rose as a weapon. Along with this sort of a system is usually an item -> slot sort of system that governs what types of items within the equipment class can be equipped where, and to represent within the mob model which slots are occupied this prevents having to check for things such as a player wear 10 sets of gauntlets at once and massively stacking up a huge armor bonus, for example.</p>
    <p>In Erlang we can opt to have objects in the game world be processes which track their own location and status (which can lead to hordes of processes sitting around for the chance to be interacted with), a directory of definitions and independent directory entries within whatever process contains them (leading to the classic "dupe" bug problem nearly every adventure-type game seems to suffer from at least once -- how do you confirm that an object contained in the location has been removed from a mob or container inventory, for example?) or a hybrid approach. While we can know even at this early stage that some sort of process-based model that is not merely a global directory is probably best, we will leave the question of exact implementation and possible fear of an efficiency or resource problem open for now.</p>
    <p>It might seem strange to leave the question of whether potentially thousands of object processes sitting around in memory, maybe noisily messaging each other all the time will be a problem later on or not. In an OOP type system this might be rather hard to fix later on if not designed out of the system right now. Gobs of dependent calls will wind up buried all over the code that will be rather annoying to factor out later on. But I've found in my experiences with Erlang that its usually best to blithly assume that the "everything is a process" concept will work out fine (unless there is some really obvious reason it won't), and once a problem is encountered later after most of the system has been written and we actually have some hard performance data, that it is relatively easy to switch message routes around and replace the representation of a single component within even a relatively complex system. A big part of this has to do with the way we will encapsulate the data we are working with, and Erlang's refusal to let us share anything between processes helps prevent us from coding ourselves into a troublesome corner in this regard.</p>
    <h4 id="mobs">Mobs</h4>
    <p>Active things! This means every beast, player, NPC, demon, perpetually kidnapped princess or whatever else we decide to include in the game world that is alive falls into this category. Anything that is attackable, killable, aggressive, prone to flee, talk-to-able, able to break the law, able to enforce the law, able to join a faction, full of hate or love or duty, or have a relationship must be a mob. Without stuff like this the game world would be pretty boring.</p>
    <p>To perform actions mobs will have to know where to send messages that represent or initiate actions, be able to somehow observe their situation in a reliable way, maintain an inventory, know what state they are in (awake, sleeping, in combat), have some mechanism of determining the effects of received offensive and defensive actions balanced against ongoing effects that influence the impact of such received actions. This implies that mobs must have some mechanism for being spawned, being hurt, being healed, dying, and being respawned.</p>
    <p>But that is just life and death. The whole range of things that occurs between a mob's spawning and its death is what we are really interested in. How do mobs communicate? Not in the sense that their processes send messages to other processes, but within the semantics of the game world. Can a player's avatar talk to another player's avatar? How does this happen? Obviously mobs other than players are going to move around. Where are the decisions for the NPCs made? Within the mob model, in some global process that controls everything players aren't controlling, or by some other process? Critically for us as programmers, we have to find some design that makes the interface between mobs in general and other elements of the game world as perfect an abstraction as possible, so that the design of locations and objects will not have to take into account whether the mob processing sending it a message is an NPC, a player, or some other mobile entity. This is not terribly hard once we realize how important this form of abstraction is, but if we hadn't thought things through this far and simply sat down to write out the entire game system in one huge module we would quickly find ourselves in trouble.</p>
    <p>This idea that mobs must be abstracted from other elements of the game world, and that mobs must have some mechanism for making decisions brings up an interesting aspect of Erlang design. Let's consider the difference between an NPC and a player character. A player character is connected to a player across the network somehow and this player is making decisions in his mind and sending commands back to the mobs which it is acting upon. The NPC is somehow making decisions on its own. We can either design two completely different mob modules, one for NPCs and one for PCs, where the NPC contains some AI mechanism and the PC contains some network connection handling code. This requires we develop a strict protocol or interface definition among the game elements that are considered mobs, and adhere to it within the design of both NPCs and PCs. Locations and objects would have no way of knowing whether they are communicating with an NPC or a PC so long as the communication protocol perfectly abstracted the concept of mob. The other way of doing things is to design a generic mob concept which knows how to interact with the world and to accept commands (like the PC mob above, but without the network code), and then develop a "controller" sort of process which might be a "PC controller" type that knows how to talk to players and an "AI controller" type that knows how to make NPC decisions.</p>
    <p>Whatever we decide, it will have an impact on how development will go and how easy it is to change things around in the future. If we create two different mob types, then the protocol that both mob types must adhere to spans every point of interaction with every other game element. This is burdensome if we want to implement mounts, for example, because every place that relates to mount implementation will have to change across both the NPC and the PC code. in most code this is handled by slowly crippling the functionality of NPCs in favor of spending development effort on adding features to PCs. If, on the other hand, we develop a general mob process and then place a controller behind it, we can much more easily develop a flexible system. With such a design it would even be trivial to permit players to take over control of mobs in progress, or pass control of their characters to AI controllers in the middle of play instead of renting a room at an inn or simply idling out in space. This sort of design is not just better because it will ease our burden as programmers, but its better because it enhances the options for how the system can be made to behave.</p>
    <p>Controllers and mobs will be discussed in more detail later on</p>
    <h3 id="unseen">That which is unseen</h3>
    <h4 id="ways">Ways</h4>
    <h4 id="traps">Traps</h4>
    <p>At the beginning of the <a href="./001-001_concept.html#mobs">Mobs</a> section above I listed a series of descriptive qualities that mobs might have. Throwing out so manu descriptions in terms of possible actions, adjectives and influences is useful to shape our thinking about the game world. For example, above I wrote "attack" but did not write "cast a spell". We should consider whether, for example, we want to include traps within the game world, and if so what sort of mechanism makes a trap work, and whether a trap is attacking, casting a spell, or acting on its victim by some entirely different mechanism. In short, we have to determine whether a trap is a "stationary mob", a mechanic governed by its hosting location, or some independent means that will require a new module that defines a trap as its own process. It is not particularly important at this stage whether we decide to include traps or not, but that we consider how to design a system in which traps are not impossibly difficult to implement.</p>
    <h4 id="controllers">Controllers</h4>
    <h2 id="thoughts">Thoughts on implementation</h2>
  </div>
</body>
</html>