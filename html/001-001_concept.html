<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" media="screen" />
  <link rel="stylesheet" type="text/css" href="erlmud_p.css" media="print" />
  <title>ErlMUD Notes: Concept | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="concepts">ErlMUD Concepts</h1>
    <p>Erlmud is a simple Multi-User Dungeon that runs over TCP. It is inspired by the fantastically well executed MUD system found at <a href="http://www.wotmud.org">WoTMUD</a> and joyful memories of playing dialup BBS text door games before the advent of residential internet. It is written in a way that takes advantage of Erlang's concurrent, strict message-passing model the few promises provided by the Erlang runtime.</p>
    <p>The system itself is written several times iteratively, gradually adding features and — most importantly for the purpose of this project — evolving in terms of code style from a primitive, ad hoc system that provides nothing more than a conceptual skeleton for the system that is ultimately desired, to a full-blown production style system that would (hopeully) not drive future maintainers mad with the urge to do violence to the original authors.</p>
    <p>This chapter begins by discussing some aspects of design that are common to any project, details the primary elements necessary to create a MUD game world, and then discusses secondary elements and other "unseen" aspects of the project which are necessary for implementation. The purpose is not to hash out every detail in prose, but rather to think about the problem in a general way and discover some of the unobvious issues that will have to be dealt with in order to implement a game system where we can deal with the primary elements at the level we want.</p>
    <h2 id="elements">Elements</h2>
    <p>In any project there are two categories of elements. There are those elements which obviously must be a part of the design, either because they represent a resource we know is required beforehand or because interacting with these elements is the purpose of the program. At the outset of the project this is what is seen.</p>
    <p>There are other elements, however, which are not so obvious and must be discovered through exploration and experimentation. The exploration part involves working through the problem space itself, discovering exactly what it means to handle the problem. The experimentation part consists of trying different methods to handle the problem and evaluating the resulting system by some balance of criteria to determine what the "right" design should look like (or, more often, the "least wrong" design). As the problem is explored and little experiments progress developers will come to the inevitable realization that handling the problem is not as easy as it initially appeared, that too much understanding of the problem was assumed at the outset, and that previously unconceived elements are necessary to deal with the problem. This is what is not seen.</p>
    <p>One way of looking at this is to say that the "seen" bits represent a basic description of the problem, and the "unseen" bits represent the implementation. Its the difference between reading the definition of a square root and coming up with an algorithm to actually derive them systematically. Erlang is a very high level language in many respects, but unfortunately it is not so advanced that we can simply spin up the runtime and say "make me a program that does X" and get what we want.</p>
    <p>When writing software for ourselves it is usually the unseen bits that bite us in the ass later. The "unseen" ass-bitings come in a striking variety of forms. When writing software for customers, however, the most frequent problem is that the customers are themselves not able to "see" the parts that should be initially "seeable" to begin with. Some customer engagements can be quite a rodeo. The typical solution most programmers seem to have adopted is to jump ship just after initial release and leave users and future maintainers to discover the need for kevlar underpants on their own. Sometimes violent thoughts cross my mind when realizing I've inherited a system written by such folks.</p>
    <p>The fact that there are obvious elements and unobvious elements of the system is part of why projects must evolve as they move forward. Sometimes an "evolution" means simply tweaking an interface or adding some method of type checking to catch latent mistakes early, sometimes it means radically changing a data schema, and sometimes it means a general re-write because we discover that a current approach is not working (or often that it works, but is unbearably costly to persue). We will see a broad range of evolutions in ErlMUD as it grows from a humble concept in prose to a basic system sketched in raw Erlang to a solid OTP application.</p>
    <h3 id="seen">That which is seen</h3>
    <p>The primary elements we want to deal with in a MUD are:</p>
    <ul>
      <li>locations</li>
      <li>objects</li>
      <li>mobile entities</li>
    </ul>
    <p>A location is a space within which play can occur. Locations connect to other locations. Travel is affected by having an entity leave one location as it enters another. The idea that locations must connect to one another to form a map, and that this map must make enough sense to players that it forms the basis for a playable world will inform our decisions about how to design a process that represents a location, what responsibilities a location might take on,
    and what (if any) accessory processes a location may require in the support of fulfilling its role.</p>
    <p>Objects are things which are not mobile or alive. Within this broad definition of objects we find anything else in the world that might not be alive but is also not a location: weapons, armor, consumables, light sources, money, clothing, food, containers, etc. The idea that some items may have a limited lifespan, and therefore have a way of being created and destroyed, picked up, placed within containers, act as containers, and maintain enough state to influence other elements of the game system tells us that the design of objects is not entirely simple, and may not even fit within a single definition. Perhaps a food object should be defined differently than a weapon object, but adhere to a similar generic interface of "object". Maybe objects should be a central digest instead of being processes. We're not sure at this point, but it is certain that being able to interact with game-world objects in a natural way is a system requirement.</p>
    <p>Mobile entities (aka "mobs") are the focus of the game. Mobs are what do the verby things in MUDs. They are the world creatures, the NPCs, the player avatars, the predators and the prey. Without them the MUD would be a pretty boring place. Knowing that all the above types of characters and creatures which occur in MUDs are mobs indicates a few things. Namely, that while a general definition of mob may suffice, the controlling elements that make decisions for mobs may require a bit of diversification.</p>
    <p> The above three elements form the basis for the game itself, but this tells us nothing about how they should be created, managed, found within the game system, communicated with, or really anything else about the system.</p>
    <p> In terms of an Erlang program this is actually OK. With just this limited definition we can begin to explore the problem space in more depth. First we will think through the basic problem of how to model everything as processes, and simply assume that this is a reasonable approach. Then we will consider the problem of how to initialize these processes and have them communicate. We will make these ideas concrete by writing some elementary wishful-thinking code that describes the ideas in more detail, and go as far as making some of that code actually work in some very limited way.</p>
    <p>I usually find it useful to begin modeling a system as if everything were a process, and not really worrying much about data structures until I have a reason to. If we abstract our data and communication methods properly, changing things like that in the background are typically not too much trouble. A surprising amount of the time any nagging performance worries we might have about having "too many" processes turn out to have been unfounded, or even contrary to high performance in a massively parallel environment. With more processes it is easier to scale "out" and not "up". This is an early part of removing bottlenecks by never creating any.</p>
    <h4 id="locations">Locations</h4>
    <p>A location is a self-contained place within the game world where actions which immediately affect mobs take place. It is the physical limit of immediate physical interaction, the limit of object observability and availability, the "initial aggression" horizon, and generally defines the boundary of awareness and mob/mob, mob/object, mob/location and object/object interaction. Exceptions will arise, of course, but as a general concept locations will define the interaction boundary among other elements. Examples of exceptions to this would be sending private messages to other players across the game world, global chat, a mail system, a "zone" system where locations belong to a group, etc. — if we decide to implement such a things. If we can write a design so that implementing exceptions is not impossible we will be doing ourselves a favor.</p>
    <p>In an imperative or OOP language the locations, objects and mobs are elements in a series of searchable data structures, and a host of functions or methods are created to conduct relational operations on them quickly. It makes no real difference if one writes <code>attack(&amp;attacker, &amp;target)</code> or <code>attacker.attack(target)</code> or whatever. The core of the system is a few data structures that must be highly performant, and concurrent activity is rather difficult to model here (though running client connections through a pool of connection workers is can be beneficial).</p>
    <p>It would be possible to create a system similar to this in Erlang, but it would not be a natural fit for the style of programming Erlang represents. Imagine having three processes, each scanning their internal state, blocking the others lest some related state change before an answer to one of ten-thousand concurrently occurring attacks is processed! Ouch! In C, sure, but in Erlang, no way. In Erlang we have other processes to think about. Whereas "everything is an object" in a language like Python, in Erlang "everything is a process". What sort of things do locations do? For one thing, they contain other stuff. We know that they define the physical boundary of interaction among other elements of the game world, and we know that they should maintain a record of their entry and exit ways.</p>
    <p>While one could model a system this way in an OOP language, it is almost never actually done, partially for reasons of conceptual difficulty, and partially for reasons of early optimization in the minds of the developers. In most OOP languages we can fall back on quick and immediate access to global references, shared state, and other environmental elements presented in an environment of shared or single execution. In Erlang, however, this is not the case. There are no objects or global data references to be had. No state is shared among processes, and <em>everything is a separate process</em>. The only way a mob can know it is in a particular location is to either ask a global directory process where it is by sending it a message, asking a location its identity on entry and remembering it, or some other relatively indirect way of signaling to the world that it needs to know or already does know its location.</p>
    <p>This is where the role of locations really comes into play. Locations are the arbiters of physical activity and define the boundaries of interactivity. If a mob performs an action, it should be represented as a message to the present location, and that location must broadcast it to the other occupants or not, as the location itself is the only one that has a perfectly current idea what other elements are present just then. When a mob "says" something, it says it to the room, and the room broadcasts it to the other mobs. When a player drop an item, it sends a message to the present location that an item has been added. When a mob attacks another mob the attack initiation must pass through the location to the target to confirm that the combat situation is valid. When a mob attempts to exit in a particular direction, it is the room that must determine whether or not the way exists and is available just then</p>
    <p>Hmm. "Whether the way is available?" Let's think about that for a moment. A way between two locations is not such a simple thing. A way could be a door or a path. Doors can be shut, doors can be locked, and adjacent locations, being processes written by our imperfect fingers running on imperfect hardware, may be down for some reason. So a way is not so simple. This requires considerable thought. Let us tuck this into the back of our minds for now, knowing that we will have to deal with the not-so-trivial concept of ways between locations later on.</p>
    <h4 id="objects">Objects</h4>
    <p>Here we do not mean "objects" as in higher order functions that know how to dispatch, or structs that have better syntax for calling functions they contain pointers to, or whatever. Here I mean "game world things". A torch, a bit of grass, a delicious cheeseburger, a weapon, a pair of pink pants, etc. These are the objects of the game world. It is obvious that different object types exist, and that different rules must exist for different object interactions, at least to some degree. How should this be modeled?</p>
    <p>In a C-style game system objects are usually just structs that contain current information and a pointer to static, definition type information. So if the game system permits weapons to have declining durability, for example, the struct representing the weapon would maintain a record of its current "health" status, and a pointer to things like its max health, its effectiveness, offensive bonus, weight, and whatever else about it that might be significant but unchanged by its health status. Within this static information would be a record of its class type, usually something like an enum <code>{weapon, shield, armor, food, drink, ...}</code> and this would be checked against a list of permitted actions to enable the eating of a ham, but prevent wearing a ham as a helmet or wielding a rose as a weapon. Along with this sort of a system is usually an item -> slot sort of system that governs what types of items within the equipment class can be equipped where, and to represent within the mob model which slots are occupied this prevents having to check for things such as a player wear 10 sets of gauntlets at once and massively stacking up a huge armor bonus, for example.</p>
    <p>In Erlang we can opt to have objects in the game world be processes which track their own location and status (which can lead to hordes of processes sitting around for the chance to be interacted with), a directory of definitions and independent directory entries within whatever process contains them (leading to the classic "dupe" bug problem nearly every adventure-type game seems to suffer from at least once — how do you confirm that an object contained in the location has been removed from a mob or container inventory, for example?) or a hybrid approach. While we can know even at this early stage that some sort of process-based model that is not merely a global directory is probably best, we will leave the question of exact implementation and possible fear of an efficiency or resource problem open for now.</p>
    <p>It might seem strange to leave the question of whether potentially thousands of object processes sitting around in memory, maybe noisily messaging each other all the time will be a problem later on or not. In an OOP type system this might be rather hard to fix later on if not designed out of the system right now. Gobs of dependent calls will wind up buried all over the code that will be rather annoying to factor out later on. But I've found in my experiences with Erlang that its usually best to blithly assume that the "everything is a process" concept will work out fine (unless there is some really obvious reason it won't), and once a problem is encountered later after most of the system has been written and we actually have some hard performance data, that it is relatively easy to switch message routes around and replace the representation of a single component within even a relatively complex system. A big part of this has to do with the way we will encapsulate the data we are working with, and Erlang's refusal to let us share anything between processes helps prevent us from coding ourselves into a troublesome corner in this regard.</p>
    <h4 id="mobs">Mobs</h4>
    <p>Active things! This means every beast, player, NPC, demon, perpetually kidnapped princess or whatever else we decide to include in the game world that is alive falls into this category. Anything that is attackable, killable, aggressive, prone to flee, talk-to-able, able to break the law, able to enforce the law, able to join a faction, full of hate or love or duty, or have a relationship must be a mob. Without stuff like this the game world would be pretty boring.</p>
    <p>To perform actions mobs will have to know where to send messages that represent or initiate actions, be able to somehow observe their situation in a reliable way, maintain an inventory, know what state they are in (awake, sleeping, in combat), have some mechanism of determining the effects of received offensive and defensive actions balanced against ongoing effects that influence the impact of such received actions. This implies that mobs must have some mechanism for being spawned, being hurt, being healed, dying, and being respawned.</p>
    <p>But that is just life and death. The whole range of things that occurs between a mob's spawning and its death is what we are really interested in. How do mobs communicate? Not in the sense that their processes send messages to other processes, but within the semantics of the game world. Can a player's avatar talk to another player's avatar? How does this happen? Obviously mobs other than players are going to move around. Where are the decisions for the NPCs made? Within the mob model, in some global process that controls everything players aren't controlling, or by some other process? Critically for us as programmers, we have to find some design that makes the interface between mobs in general and other elements of the game world as perfect an abstraction as possible, so that the design of locations and objects will not have to take into account whether the mob processing sending it a message is an NPC, a player, or some other mobile entity. This is not terribly hard once we realize how important this form of abstraction is, but if we hadn't thought things through this far and simply sat down to write out the entire game system in one huge module we would quickly find ourselves in trouble.</p>
    <p>This idea that mobs must be abstracted from other elements of the game world, and that mobs must have some mechanism for making decisions brings up an interesting aspect of Erlang design. Let's consider the difference between an NPC and a player character. A player character is connected to a player across the network somehow and this player is making decisions in his mind and sending commands back to the mobs which it is acting upon. The NPC is somehow making decisions on its own. We can either design two completely different mob modules, one for NPCs and one for PCs, where the NPC contains some AI mechanism and the PC contains some network connection handling code. This requires we develop a strict protocol or interface definition among the game elements that are considered mobs, and adhere to it within the design of both NPCs and PCs. Locations and objects would have no way of knowing whether they are communicating with an NPC or a PC so long as the communication protocol perfectly abstracted the concept of mob. The other way of doing things is to design a generic mob concept which knows how to interact with the world and to accept commands (like the PC mob above, but without the network code), and then develop a "controller" sort of process which might be a "PC controller" type that knows how to talk to players and an "AI controller" type that knows how to make NPC decisions.</p>
    <p>Whatever we decide, it will have an impact on how development will go and how easy it is to change things around in the future. If we create two different mob types, then the protocol that both mob types must adhere to spans every point of interaction with every other game element. This is burdensome if we want to implement mounts, for example, because every place that relates to mount implementation will have to change across both the NPC and the PC code. in most code this is handled by slowly crippling the functionality of NPCs in favor of spending development effort on adding features to PCs. If, on the other hand, we develop a general mob process and then place a controller behind it, we can much more easily develop a flexible system. With such a design it would even be trivial to permit players to take over control of mobs in progress, or pass control of their characters to AI controllers in the middle of play instead of renting a room at an inn or simply idling out in space. This sort of design is not just better because it will ease our burden as programmers, but its better because it enhances the options for how the system can be made to behave.</p>
    <p>Controllers and mobs will be discussed in more detail later on</p>
    <h3 id="unseen">That which is unseen</h3>
    <p>In thinking through the three main elements of the MUD some indications that a three-module codebase was going to be insufficient. When discussing locations we mentioned that locations have quite a few more responsibilities than their imperatively implemented counterparts do, and while we're sure that locations will be required to handle some message broadcasting (notifications to everyone in the location), directory lookups (who or what is in the location), and respond to basic queries (give the room description, name, etc.), we left open the non-trivial question of how locations are to  be interconnected. When discussing objects and mobs a list of attribute descriptions was given for mobs, but not for objects. What objects can "do" (if they can do anything) and what mobs can do, and where some crossover may exist was never addressed. Inparticular, we never developed a concept for how a world object that is not a mob might behave. Ultimately, we have no idea about how to implement time-decaying foods, traps, or anything else of that nature. The trap case is discussed below as an example. The discussion about mobs also touched on a very important subject: the mob controllers. These issues, and any complications arising immediately from them, will be discussed in more detail below.</p>
    <h4 id="ways">Ways</h4>
    <p> In particular, the issue of how locations know its safe to permit a mob to depart to a certain adjacent location, how it knows the adjacent location's process is up, and how to handle the concept of open/closed/locked ways or doors to other locations has been left unaddressed, but that little sense programmers often have that something is not quite as simple as it seems on the surface is telling me that this area of functionality is both complex enough that it requires its own logic and orthogonal to the basic duties of a location to justify being placed in a separate module.</p>
    <h4 id="traps">Traps</h4>
    <p>At the beginning of the <a href="./001-001_concept.html#mobs">Mobs</a> section above I listed a series of descriptive qualities that mobs might have. Throwing out so manu descriptions in terms of possible actions, adjectives and influences is useful to shape our thinking about the game world. For example, above I wrote "attack" but did not write "cast a spell". We should consider whether, for example, we want to include traps within the game world, and if so what sort of mechanism makes a trap work, and whether a trap is attacking, casting a spell, or acting on its victim by some entirely different mechanism. In short, we have to determine whether a trap is a "stationary mob", a mechanic governed by its hosting location, or some independent means that will require a new module that defines a trap as its own process. It is not particularly important at this stage whether we decide to include traps or not, but that we consider how to design a system in which traps are not impossibly difficult to implement.</p>
    <h4 id="controllers">Controllers</h4>
    <h2 id="thoughts">Thoughts on implementation</h2>
    <p>At this point we have a firm enough idea about how the primary <em>game</em> elements could be sketched out in psuedo code (or crayon, for that matter), but the elements of the<em>system</em> have not yet been addressed at all. How does the system start? What do we call? How do we contact it? Where do locatios, objects and mobs come from in the first place?</p>
  </div>
</body>
</html>