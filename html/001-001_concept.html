<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" />
  <title>ErlMUD Notes: Concept | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="concepts">Concept</h1>
    <p>ErlMUD is a simple Multi-User Dungeon that runs over telnet, inspired by joyful memories of playing dialup BBS door games and MUDs before the advent of residential internet. It is written in a way that takes advantage of Erlang's concurrent, strict message-passing model and the few promises provided by the Erlang runtime.</p>
    <p>This commentary follows the development process of ErlMUD as it undergoes changes, feature additions and design evolutions. The code is written several times iteratively, gradually adding features and — most importantly for the purpose of this project — evolving in terms of code style from a primitive system of limited functionality to a full-blown production system that would (hopefully) not drive future maintainers mad.</p>
    <p>This chapter begins by discussing some aspects of design that are common to any project, details the primary elements necessary to create a MUD game world, and then discusses secondary elements and other "unseen" aspects of the project which are necessary for implementation. The purpose is not to hash out every detail in prose, but rather to think about the problem in a general way and discover some of the unobvious issues that will have to be dealt with in order to implement the game system. The goal of the implementation is to elevate the primary game elements to the level of abstraction that we want to deal with so we can dispense with the details under normal conditions.</p>
    <h1 id="elements">Elements</h1>
    <p>In any project there are two categories of elements. There are those elements which obviously must be a part of the design, and those that require discovery on the part of the developer.</p>
    <p>The obvious parts are clear to us either because they represent a resource we know is required beforehand or because interacting with these elements is the purpose of the program. At the outset of the project this is what is seen.</p>
    <p>There are other elements, however, which are not so obvious and must be discovered through exploration and experimentation. The exploration part involves working through the problem space, discovering exactly what it means to handle the problem. The experimentation part consists of trying different methods to handle the problem and evaluating the resulting system by some balance of criteria to determine the "right" design (or, more often, the "least wrong" design). As the problem is explored and little experiments progress developers will come to the inevitable realization that handling the problem is not as easy as it initially appeared, that too much understanding of the problem was assumed at the beginning, and that previously unconceived elements are necessary to deal with the problem. At the outset of the project this is what is not seen.</p>
    <p>The "seen" bits represent a basic description of the problem and the "unseen" bits represent the implementation. This is analogous to the difference between reading the definition of a square root and coming up with an algorithm to derive them. Erlang is a very high level language in many respects, but it is not so advanced that we can simply plug in a mic and demand "Make me a system that does X!" and get what we want.</p>
    <p>When writing software for ourselves we usually know what features we want and can quickly enumerate the "seen" bits. It is our lack of understanding of the unseen bits that bites us in the ass later. (The "unseen" ass-bitings come in a striking variety of forms!) When writing software for customers, however, the most frequent problem is that the customers are themselves not able to "see" the parts that should be initially "seeable". (Some customer engagements can be quite a rodeo...) The solution most programmers have adopted is to jump ship just after initial release and leave users and future maintainers to discover the need for Kevlar underpants on their own.</p>
    <p>The fact that there are obvious and unobvious elements of the system is part of why projects must evolve as they move forward. Sometimes an "evolution" means simply tweaking an interface or adding some method of type checking to catch latent mistakes early, sometimes it means radically changing a data schema, and sometimes it means a general re-write because we discover that a current approach is not working (or that it works, but is too costly to pursue). We will see a broad range of evolutions as ErlMUD grows.</p>
    <h1 id="process">The process</h1>
    <p>How do we know what elements we will need? How to we discover the "unseen" bits? What part should we try to write first once we know what we're trying to do?</p>
    <p>There is an entire subindustry built around trying to sell "methodologies" to software engineers, and especially managers who don't write code themselves. They all claim to have figured out the "right" way to do this and write the code as well. Sadly, they are all full of crap. Just crap. Some methods work well for certain types of teams and don't for others. Some work well in a certain customer or business environment, some work well when paired with a certain language style or whatever. But there is no such thing as a right way to do this and you'll always be learning how to improve your own methods.</p>
    <p>I'm going to be a bit of a traditionalist up front here and commit to a very early top-down approach to the problem of system design. This should work out reasonably well for two reasons: we know what a MUD does, there are many examples we can refer to in the wild already; and the point of ErlMUD is to server as a platform for demonstration of various styles of Erlang and OTP. Even if I have to go a bit further into "big design up front" than I normally would, there is a great value in being able to explain the system we want early on so that I can focus on the main point of this commentary, which is to demonstrate how a single project can manifest itself in different Erlang and OTP styles over time, and point out the tradeoffs involved.</p>
    <p>Once we do the big design bits, though, we'll start mixing styles a bit, working a bit on the tiny bits and a bit on the big bits, and eventually mesh the two together into a working system. I don't know any other way to write an "actor model" system than to start writing some actors, and that means somewhere along the way I have to dive below the "top level" and at least work somewhere in the middle. I think this is a fairly ordinary way of writing Erlang code, and I don't think I've ever seen any "methodology" that this adheres to. But that is unimportant.</p>
    <p>So what we are going to do is describe our problem in a general way, then see if we can pick apart the conceptual pieces of it and segregate them into mechanical bits. Then we are going to step through the first part of the pieces and see what we need to do to implement that, and check and make sure that the next bits aren't impossible to implement based on our initial design.</p>
    <h2 id="problem">The Problem</h2>
    <p>"Write  MUD."</p>
    <p>Sounds simple when stated that way but it doesn't give us much guidance on how to go about it. What can we break that down into? If we take it at face value then its OK to hard-code world mechanics, a gameplay system, even game world and character data right into the source of the project. But that's a bad thing. How do we avoid this?</p>
    <p>We can split almost any piece of software into three general pieces:
    <ul>
      <li>platform</li>
      <li>operating rules</li>
      <li>instance data</li>
    </ul>
    <p>Consider a text editor: there is the editor program itself that manages the widow and user interface; there are contextual rules like settings, a plugin system, "modes", etc.; and there is the text file data users are actually interested in. Consider a browser: there is the browser itself that manages the window, socket connections, etc.; there are operating rules like plugins, scripting languages, rendering engines, download managers, email subsystems, ftp clients, etc.; and then there are the web pages that users are looking at.</p>
    <p>Not every piece of software is structured like this, but most of them are. Even very "simple" programs often work this way. Think about the programs included in GNU coreutils, for example (grep, sed, cat, head, tail, etc.). Nearly all of them have a core routine (platform), a switch or script interpretation system (operating rules), and input data to operate on (instance data). Most of the time when you run across a program that doesn't follow this form you're looking at an early alpha, a convoluted codebase, or a throwaway program. MUDs run for years, sometimes decades, so we can't commit to such an aggregation of concerns in our design.</p>
    <p>A MUD system needs a basic world simulation platform, rules that define the gameplay, and world data.</p>
    <p>We need to identify what a MUD is as a platform, define a way of defining a gameplay system, and a way to define world objects that work within that platform and gameplay system.</p>
    <h3 id="platform">The Platform: A World Simulator</h3>
    <p>"MUD" stands for "Multi-User Dungeon". MUDs are multiplayer adventure games, usually accessible via telnet or ssh, and generally provide a line-based text interface. Locations in MUDs are defined as "rooms" or "sectors" which are often grouped into "zones" which share some common behavior. Entities in MUDs are animate "mobiles" (or "mobs") and inanimate "objects". A player character is represented as a mob which is under a user's direct control. An arbitrary range of movement methods between locations is defined, often unique to each game system, and an arbitrary range of interactions is defined between animate→animate and animate→inanimate entities.</p>
    <p>Combat is often a strong component of a game world, but in some MUDs chat, emotive actions or roleplay is the focus. In any MUD, whether combat or roleplay based, there is a strong user expectation of community involvement. The primary motivation of most MUD players is themed interaction with an online community, not mere interaction with the game world itself. Many MUDs run for decades with the same general player base, and are expected to be generally stable for as long. Most MUD systems are usable as backends for either combat/adventure or chat/social servers. In a certain sense, MUDs can be considered super-advanced chat servers, though it seems that most MUD authors do not think of them in this way.</p>
    <h3 id="operating_rules">Operating Rules: A Gameplay System</h3>
    <p>The whole world of options is open to us right now, since we haven't committed to anything. We could make ship-trader mechanics, D&amp;D mechanics, card-battle mechanics, timer-based mechanics, sprite/glyph collision combat, or whatever else we might come up with. While each combat system is interesting to consider (isn't it fascinating how many combat systems have been invented just in text games?), it is even more interesting to consider how we might write the combat system as an orthogonal part of the game world itself. This part is rarely done, mainly because the difference between the world as a platform and the gameplay as a mechanical system is usually not considered by game authors as the begin their design task. Part of the reason is that game design is a skill that is usually practiced under duress: business pressure, Christmas release deadlines, late spring release deadlines for American school break release, the company being bought out by a lawfirm that doesn't know anything about games but that they are lucrative and "all that programmers do is type anyway", and any number of other things that are not very conducive to the task of actually understanding how the components of a world simulation work together.</p>
    <p>Are we building a Trade Wars 2002 style system that supports traders moving ships full of cargo around and battle involves squadrons of fighters attacking each other until a critical hit is scored on the main ship? Do we want a card-game style combat system similar to Pokemon, Magic the Gathering or Baten Kaitos? Do we want a traditional Diku or Circle style combat system where combat is fairly transparent within the game system, and stabbing, sneaking, equipment upgrades, etc. are an integral part of things? Do we want a Rogue-esque, Operation Overkill II style world where a text map is displayed and players switch from travel to combat modes? A non-travel encounter system like LoRD or Usurper? Or a first-person text dungeon crawler</p>
    <h3 id="instance_data">Instance Data: Maps and Items and Characters Oh my!</h3>
    <p>Different game worlds might have radically different themes. If we do a good job writing ErlMUD then a system operator who wants to set up an ErlMUD based MUD won't need to know Erlang, won't need to know the details of telnet or TCP, won't need to be familiar with the vagaries of OTP or any other forms of modern magic. Anyone who wants to set up a server should be able to imagine a game world that complies with the mechanics of gameplay defined above, and write the details of the game world they want without messing abuot with these things. That means that the details of different types of mobs, where they spawn, what the map looks like, where traps, one-way doors, key mysteries, special effects (like magic or high technology), available items of what class, trade system, etc. should be something the system operator should be able to define without writing any new logic, so long as the world he envisions does not require the implementation of new system or gameplay features. This means one ErlMUD based world might be a Tolkien-like world full of goblins, great warriors, elf princesses or whatever else, another might be a postapocalyptic world of survivors, mutants and zombies set far in the future, and another might be a frontier colonial adventure set on Colonial Mars where the enemies are human-built robots gone wrong and dangerous outlaws living in the badlands.</p>
    <p>One consideration with the building of worlds is whether we should build tools for creating the world, a facility for world creation within the MUD itself (a specially-priviledged player being able to spawn rooms and things on the fly), or just let the sysops deal directly with text files that contain settings information. Right now it doesn't really matter, but this will be something to consider later on. The easier it is for a sysop to express what they want the better we are doing in building a system that users will actually care about.</p>
    <h1 id="distillation">Distilling Elements</h1>
    <p>From the description above, and from taking some time out to play a MUD or two (seriously, try one), we can determine that the simulated world elements we need to deal with are:</p>
    <ul>
      <li>locations</li>
      <li>objects</li>
      <li>mobs</li>
    </ul>
    <p>We can defer the gameplay rules by making them apply to external gameplay modes. For example, combat rules can apply when a mob is "in combat", a trade or barter subsystem can apply when a mob is "in trade", and so on. This way each mode essentially represents a mini-game that fits smoothly within the context of the world simulation, and we don't have to care what sort of combat, trade, spell creation, or other mini-game modes are available within the world so long as we know ahead of time that we want a form of those systems included in some way.</p>
    <p>While we can defer specific operating rule mechanics until later, we can't completely ignore the instance data. At the very least, we need a way to create a skeleton set of game world data so we can try out on the different elements of the world simluation and actually have something happen. In the same way that the initial focus is not yet on the gameplay mechanics it is also not on the instance data at this point, so for now all we're going to do is create a simple way of passing a list of terms to some init function and that will suffice for now.</p>
    <p>We've discussed the game system, but not the scaffolding necessary to get the thing spun up. We'll go into more detail about this later on, but for now some obviously necessary system elements are:</p>
    <ul>
      <li>telnet interface</li>
      <li>chat system</li>
      <li>player registry</li>
      <li><code>erlmud:start/0</code> — it has to go somewhere!</li>
    </ul>
    <p>So far, this is what we can see. Let's take a closer look at the world simulation elements and system scaffolding and think through what supporting elements we might need to implement.</p>
    <h1 id="world_elements">World Elements</h1>
    <h2 id="locations">Locations</h2>
    <p>A location is a self-contained place within the game world where actions which immediately affect mobs take place. Our guildeline is that if a mob performs a physical, verbal, or emotive (or "emote") action it should only be visible to or have a direct effect on another mob in the same location. This should be distinct from the chat system and probably most other actions that can occur at a distance.</p>
    <p>There are two basic ways to implement locations. They could be entries in a universal registry where mobs, objects and associations among locations can be tracked in tables that indicate their relationship to the location. Alternatively, they could be processes which do their own entity tracking and are directly responsible for arbitration of physical actions.</p>
    <p>If we use a global-registry then we have the problem that nearly every action in the world depends on this registry. If this were done in a single process it would be a pretty busy one, but guaranteeing consistency would be relatively simple. If it were done in a worker pool the load could be distributed, but consistency would be much more difficult to guarantee and the registry store itself would still be a bottleneck. Either way, we would be putting all our eggs in one basket. If this registry were to die so would the MUD.</p>
    <p>Consider how complex such a monster registry would become over time. Once we give too much responsibility to a single piece of code the tendency is to increase the number of responsibilities it handles over time. This is against every good practice we know as engineers, but under the pressures of real life, business, and expectant users this is what tends to happen. It is quicker to hack "just one more" feature into an already overloaded system than to sort out the tangle of responsibilities and then implement an additional feature orthogonally. One Registry To Rule Them All is actually a pretty normal design in an OOP or imperative style MUD, but I don't think its a good fit for Erlang.</p>
    <p>The other way, where each location is a process, seems more sensible to me. If locations are processes then we avoid creating any bottlenecks and crashes can occur at a small enough scale that we can probably recover from them without affecting. This design is also easier for me to reason about because it is closer to being a genuine simulation of a world. This is the way we will try first.</p>
    <p>Each location will need to keep track of whatever mobs, objects and connections to other locations are present. If a mob, object or adjacent location were to crash the location should carry on. The location's job is to arbitrate activity within the location (someone closes a door, drops an item, etc.), answer queries about its current state (who/what is here, what exits are available, etc.), and broadcast location-wide notifications (a mob enters the room, says something out-loud, etc.). This is a fairly simple list of responsibilities that we can probably model in a single process without getting confused.</p>
    <p>There is a lingering problem, though. Locations will need to keep track of the status of adjacent locations and arbitrate the movement of mobs between themselves and those other places. This means two identical processes will have to communicate, and this communication will need to be synchronous. That means we need to watch out for deadlocks. (Oh noes!)</p>
    <p>My way of avoiding this kind of deadlock is usually to create another type of process that takes care of the synchronous communication on behalf of one of the two processes. This lets me design a protocol that at least isn't guaranteed to have a deadlock built in (whether our protocol actually avoids deadlocks is a different issue, but this way at least we're not guaranteed to have one).</p>
    <p>In this case I think it makes sense to create a "way" process that represents a one-way path between two locations. This lets us create interesting maps without adding new logic the locations themselves (one-way portals, for example), and it also gives us an easy method for implementing other game elements like shuttable/lockable doors, hidden paths, temporary portals, fuel-operated warp gateways, or whatever. Separating the idea of a "way" from a "location" gives us a lot of advantages both in terms of modeling the game world and in preventing kinks from emerging in our messaging protocol.</p>
    <p>So there we have it, we've identified our first "unseen" element: ways. We'll worry about the details of ways a little later on, but its good that we have identified that locations do not stand alone within the game system.</p>
    <p>Something we glossed over up to now is how to instantiate the locations. Where do they come from? Since we will probably have a map defined in permanent storage that gets pulled during startup/reload a traditional system of supervisors that manage workers will be a good fit. We can assume, then, that we'll probably need at least a "location manager" process that spawns locations and restarts them if they die untimely deaths. There might be other things we want this process to do, like alter the map dynamically, but we don't have to worry with that for now. At this point it is sufficient to say that our second "unseen" element is a location manager that supervises the locations and that the locations are workers at the bottom of the supervision tree.</p>
    <h3 id="locman">Location Manager</h3>
    <p>Manage those locationses.</p>
    <h3 id="ways">Ways</h3>
    <p> In particular, the issue of how locations know its safe to permit a mob to depart to a certain adjacent location, how it knows the adjacent location's process is up, and how to handle the concept of open/closed/locked ways or doors to other locations has been left unaddressed, but that little sense programmers often have that something is not quite as simple as it seems on the surface is telling me that this area of functionality is both complex enough that it requires its own logic and orthogonal to the basic duties of a location to justify being placed in a separate module.</p>
    <h2 id="objects">Objects</h2>
    <p>Any inanimate thing in the world that can be manipulated is an object: weapons, armor, consumables, light sources, money, clothing, food, containers, etc. Different types of objects may have special behaviors, like food that spoils over time, or a weapon that wears out or a piece of clothing that can only be worn on the head. Objects need a way of being created, destroyed, picked up, placed in containers, act as containers, used as ingredients or food, and any other in-game action we might come up with.</p>
    <p>This tells us that the design of objects is not as easy as we may have initially thought, and may not even fit within a single definition. Perhaps a food object should be defined differently than a weapon object, but adhere to a similar generic interface of "object". Maybe objects should be a central digest instead of being processes. We're not sure at this point, but it is certain that being able to interact with game-world objects in a natural way is a system requirement.</p>
    <p>I've got three basic ways in mind about how to implement objects. One is to make a central object registry that keeps track of all objects across the game world. Another is to do things the C-style MUD way and have a library of object type definitions we can copy into structs based on the type that is needed, and mobs, locations and container objects could pass pointers to those structs around to represent associations that they track themselves. And yet another way is to make every object a process of its own, the way we do with locations.</p>
    <p>The central registry style suffers from the same problems a central location registry would, so that's out. If we thought a location registry would become a bottleneck and complex to implement, imagine how busy an object registry would be! There is a lot less travel and position checking in a MUD than object-influenced activity (every combat action might take weapon and all clothing/armor stats and total carried weight into account, for example), not to mention the variety of behaviors that would have to be coded into the object registry to implement diverse things like ingredients, food, equipment, etc. No thanks.</p>
    <p>Passing pointers around would be nice, but this isn't the way Erlang works: we can't share memory. The entire tuple representing the object would have to be passed between locations, mobs, and other objects as messages, and each of these process types would have to know how to interact with them. (For the curious: Screwing up the procedure of passing pointers or creating/destroying structs/objects to represent item passing is the source of many an item dupe bug.) If the shape of the object data ever changed, that would cause a lot of surgery throughout several other modules. Record syntax could help us there a bit, but then we'd have to share record definitions across source files, and that gets wonky. A better way would be to wrap the object data behind a functional interface, and this might be a workable solution. But where would we put the influences of objects themselves? Let's say we want to implement food that decays over time. We will need to write some logic in location code that updates the state of the food it contains to effect the decay, and we will also need to write very similar logic into mobs and container objects to make sure the same things happen there as well. And where is the code for container objects now? This is actually not sounding like such a good idea. Its simple to think about passing a tuple that represents an object in the game world, but not so simple as soon as we want those objects to exhibit some sort of behavior of their own.</p>
    <p>That leaves us with designing objects as their own processes. This lets us do all sorts of cool stuff, because we can code "object logic" directly into them and give them their own processing loops, timers, state, etc. But what about the different categories of objects? How do we make food, weapons and containers fit into the same definition? We might not be able to. I'm not so sure that objects will fit into a single definition, we may actually need several to keep our code understandable. But that's OK, because there are no constraints on process type with regard to message passing.</p>
    <p>What we really need is a messaging protocol for objects. That way objects of a certain type can identify themselves if necessary, have their own behaviors with regard to messages received and sent, and all look basically the same from the outside despite their internal differences. (Sound a bit like "duck typing"?) An oven could be a finite state machine, a container a service process, and food could be some new "food behavior" we have yet to invent. The point of defining objects as a protocol and not some specific process type is that it permits us to defer the details of any particular object type until later. We can play with this protocol early on by creating some generic object type at the outset which will grow to represent our basic object message protocol, and keep in mind that implementing special object types will require new modules that adhere to the basic protocol. Of course, to design a protocol we have to determine what to talk about first, and that means we have to establish some basic attributes common to all objects.</p>
    <p>Here we have two unseen elements: generic object attributes and the object messaging protocol. We knew at the beginning that we wanted to have objects in the game, but until now it wasn't clear that "objects" would have to be a category of process definitions which adhere to a messaging protocol as opposed to a single type of process or data structure.</p>
    <p>It might seem strange to leave the question of whether potentially tens of thousands of object processes sitting around in memory, maybe noisily messaging each other all the time will be a problem later on or not. In an OOP type system this might be rather hard to fix later on if not designed out of the system right now. Gobs of dependent calls sprinkled throughout the code might have to be fixed. But I've found in my experiences with Erlang that its usually best to blithely assume that the "everything is a process" concept will work out fine (unless there is some really obvious reason it won't), and that fixing performance issues only makes sense to worry with once some hard performance data from the actual development system we're working on is available. It is relatively easy to switch message routes around and replace the representation of components within even a relatively complex system. A big part of this has to do with the way we will encapsulate the data we are working with, and Erlang's refusal to let us share anything between processes helps prevent us from coding ourselves into a troublesome corner in this regard.</p>
    <h3 id="object_attributes">Object Attributes</h3>
    <p>Here we want to iron out two things: what are the aspects of all objects that can be interacted with, and what attributes must all objects exhibit in order to adhere to the common model of interaction. If we don't think through this part we'll never be able to create a coherent object protocol. Actually, even if we do this part, our object protocol will still be ridiculous at first, but it will at least be something other than completely stupid (like forgetting that food has weight because we only thought of weight in the context of encumberance penalties for armor or whatever).</p>
    <p>Objects are made of matter. Let's start there. Matter takes up space and has mass. Mass means weight. Space means volume. We could work these into the game system without overcomplicating things. Or could we? If we implement volume we will also have to implement volume checks everywhere (object A is light enough, but not small enough to fit into container B, etc.). That's probably not so hard to do, but its a bit more detail than most games worry over. Gameplay tradeoffs will definitely become more complex if we include volume considerations, which could be bad, but it could also result in really interesting decision making for players. We shouldn't forget about this volume idea, but for now I just want to stick with weight as a basic property of objects.</p>
    <p>Objects also have to have a name, and maybe a description that gives a bit more detail. For example, a player targets a rock by calling it a "rock" but when he performs an examine or look action, maybe a more interesting description of the rock should be displayed. So we'll include descriptions, since descriptions are our only way of conveying anything about the game world to the players, since we're not implementing any graphics.</p>
    <p>So there we have it, at least for now: objects have a name, a description and a weight. All objects exhibit these properties, regardless of type. We can implement a very primitive game world where this is true, and come back and make this more interesting a little later if we find it necessary.</p>
    <h3 id="object_protocol">Object Messaging Protocol</h3>
    <p>The basic object protocol needs to be general enough that every object of any type can conform to it without making things ridiculous, but not so specific that it interferes with whatever unique things a special object type should do. There is no doubt that the protocol itself will have to get ironed out a bit as we go along, but a good place to start with building a message protocol is basic interrogation of the object's properties. This is something we have a head start on since we already decided what the most object attributes are.</p>
    <p>Let's take one step farther than just writing a gigantic flat protocol space that looks like <code>{From, some_very_specific_request_atom}</code> and break things up a tiny bit. Objects don't really do anything, at least not basic ones. Objects don't need to know where they are, who owns them, or whatever. If we decide to implement a concept of natural ownership (the way items in <u>Oblivion</u> maintain an owner tag) then maybe it would be useful to add a way to update this, but for now we don't care. So we can get away with having the mobs and locations deal with tracking where objects are, and only worry with having a way to ask an object about its basic attributes.</p>
    <h3 id="objman">Object Manager</h3>
    <p>Manage those objectseses.</p>
    <h2 id="mobs">Mobs</h2>
    <p>Finally. the focus of the game. Mobs are what do the verby things in MUDs. They are the world creatures, the NPCs, the player avatars, the predators and the prey. Every beast, player, NPC, demon, perpetually kidnapped princess or whatever else we decide to include in the game world that is alive falls into this category. Anything that is attackable, killable, aggressive, prone to flee, talk-to-able, bound by in-game laws, factionalizable, grouppable, emotionally conscious, ridable or ownable as a pet, passengerable, or definable as friend or foe is a mob. Without them the MUD would be a pretty boring place.</p>
    <p>Knowing that all the above types of actions and attributes center around mobs indicates that while a general definition of mob may suffice at the outset, mobs will likely also require a message protocol definition that lets us write a variety of mob types that do different things but interact with the system in a similar way. This isn't so different from our discussion of objects, above, really. The main difference is that while it wasn't so obvious at first that objects should be processes, it was always clear that mobs would be. In both cases we find ourselves settling on an initial, generic implementation of each so we can explore the message protocol in more detail, knowing that we will almost definitely be writing a few unique modules that adhere to that protocol later on.</p>
    <p>The similarities between objects and mobs only goes so far. They don't do anything so they don't have players or AI controlling them. Mobs do things. How do we make those actions happen? What determines what action happens when? If we put a dog mob somewhere, will he ever leave? Will he chase rabbits on his own? Where does that go? Do we re-write a new module every time we come up with a new mob type (and then have to change all thousand of them if we ever decide to change the mob messaging protocol? Ouch!)? Something is clearly missing here. We need a controller.</p>
    <p>While it would certainly be possible to write the AI elements directly into a mob, that would pose some problems. For one thing, every mob would need different AI or else the world will be remarkably inflexible. Having an evil miniboss and the town blacksmith share the same AI would pose a problem. It also limits our options: what if we want to create a game world where all the mobs already pre-exist, and players just take control of mobs in place and play that way? Its not traditional, but its an exciting idea. What if game staff (usually called "immortals" or "imms") want to enhance roleplay possibilities temporarily by taking control of a village NPC and providing some live interaction? We can't do those things very easily if the controlling code and the mob code are intermixed. Well, to be specific, it might be possible to implement that sort of a system exactly once and never change it again, but smooth evolution of a codebase is one of the most important things we have to think about as developers, and its no good to tie a big Gordian Knot of concerns right from the start (though this seems to be the norm in many projects).</p>
    <p>To perform actions mobs will have to know where to send messages that represent or initiate actions, be able to somehow observe their situation in a reliable way, maintain an inventory, know what state they are in (awake, sleeping, in combat), have some mechanism of determining the effects of received offensive and defensive actions balanced against ongoing effects that influence the impact of such received actions. This implies that mobs must have some mechanism for being spawned, being hurt, being healed, dying, and being respawned.</p>
    <p>But that is just life and death. The whole range of things that occurs between a mob's spawning and its death is what we are really interested in. How do mobs communicate? Not in the sense that their processes send messages to other processes, but within the semantics of the game world. Can a player's avatar talk to another player's avatar? How does this happen? Obviously mobs other than players are going to move around. Where are the decisions for the NPCs made? Within the mob model, in some global process that controls everything players aren't controlling, or by some other process? Critically for us as programmers, we have to find some design that makes the interface between mobs in general and other elements of the game world as perfect an abstraction as possible, so that the design of locations and objects will not have to take into account whether the mob processing sending it a message is an NPC, a player, or some other mobile entity. This is not terribly hard once we realize how important this form of abstraction is, but if we hadn't thought things through this far and simply sat down to write out the entire game system in one huge module we would quickly find ourselves in trouble.</p>
    <p>This idea that mobs must be abstracted from other elements of the game world, and that mobs must have some mechanism for making decisions brings up an interesting aspect of Erlang design. Let's consider the difference between an NPC and a player character. A player character is connected to a player across the network somehow and this player is making decisions in his mind and sending commands back to the mobs which it is acting upon. The NPC is somehow making decisions on its own. We can either design two completely different mob modules, one for NPCs and one for PCs, where the NPC contains some AI mechanism and the PC contains some network connection handling code. This requires we develop a strict protocol or interface definition among the game elements that are considered mobs, and adhere to it within the design of both NPCs and PCs. Locations and objects would have no way of knowing whether they are communicating with an NPC or a PC so long as the communication protocol perfectly abstracted the concept of mob. The other way of doing things is to design a generic mob concept which knows how to interact with the world and to accept commands (like the PC mob above, but without the network code), and then develop a "controller" sort of process which might be a "PC controller" type that knows how to talk to players and an "AI controller" type that knows how to make NPC decisions.</p>
    <p>Whatever we decide, it will have an impact on how development will go and how easy it is to change things around in the future. If we create two different mob types, then the protocol that both mob types must adhere to spans every point of interaction with every other game element. This is burdensome if we want to implement mounts, for example, because every place that relates to mount implementation will have to change across both the NPC and the PC code. in most code this is handled by slowly crippling the functionality of NPCs in favor of spending development effort on adding features to PCs. If, on the other hand, we develop a general mob process and then place a controller behind it, we can much more easily develop a flexible system. With such a design it would even be trivial to permit players to take over control of mobs in progress, or pass control of their characters to AI controllers in the middle of play instead of renting a room at an inn or simply idling out in space. This sort of design is not just better because it will ease our burden as programmers, but its better because it enhances the options for how the system can be made to behave.</p>
    <p>Controllers and mobs will be discussed in more detail later on.</p>
    <h4 id="mob_attributes">Mob Attributes</h4>
    <p>We already know that mobs are the active force of the game and since we're writing a game system that implements a character-based D&amp;D style system that character traits are what determine the outcome of nearly every action. Mob attributes are not going to be simple. But we aren't yet concerned with implementing the game system in full just yet. We haven't even discussed the combat system or weapon/skill calculations or whatever. We don't care about these things yet. What we need to do before we think too hard about any of those things is to get a basic game world working where mobs and move around, talk to each other, use the chat system, manipulate basic objects, and be controlled by a basic AI or basic player controller. That's it. If we get these parts correct, implementing a combat system on top of it should not be hard. The hard part about combat systems are the combat systems themselves and the interactions among all the factors that go into a combat action calculation. I don't even want to think about that until we've got a basic system functioning. That's trying to establish the game system for chess before you've even determined how the board works.</p>
    <p>One might ask why we are setting our sights so low. My answer is that this is simply the software version of going ugly early. Sure, if an opportunity for improvement comes along later we'll take it, but for now let's stick with what we know will be reliable, and then build upon that.</p>
    <p>So what are basic mob attributes? It might be a good idea to make them similar to basic object attributes: name, description and weight. Actually, we can leave weight off for now, because we don't care. If we don't care about a mobs D&amp;D style stats yet, we also don't care about the weight of it. At the moment we care more about what mobs do than what they are, so we'll just leave it at that.</p>
    <h3 id="mob_protocol">Mob Messaging Protocol</h3>
    <p>The mob protocol is a bit of a complex thing to discuss. The reason is that mobs are the hub of nearly all interaction in the game. Being the center of activity means that mobs define as many protocols as the number of unique sorts of activities they engage in. We should start with just the basics to permit a "live" game world to exist without getting too far down into the weeds.</p>
    <p>We want to start with just a few requirements: movement, observation, object manipulation, and communcation. That's it. We're leaving out all sorts of stuff: trade, combat, equipment, time, thieving, justice, etc. and just about every other conceivable gameplay element we might want later on. That's because we're just working on the game world right now and not the gameplay (much less building an actual game on top of all that yet).</p>
    <p>Let's think through these for a moment. Movement is probably the most complicated thing to implement because it involves a collection of processes working together to accomplish a task. If we put a mob into a location and it wants to move, we need some way to indicate this to the location, then the location must check that the mob really is in the location, that the outgoing way is open, and then the way itself must let the receiving location know who is coming. The outgoing location needs to confirm that it dropped its record of the outgoing mob and the incoming location should confirm it somehow. We could combine the dropping from one location and confirmation of the drop without any issues (the mob doesn't care if it is locationless for a moment), and we can combine the incoming location's receipt of the mob with adding it to the new location's state. But this remains a non-simple chain of interactions to effect movement and it must be synchronous so that we can handle special cases in the future without encountering wacky corner asynchronous corner cases (like travel-related messages arriving really late, or the outgoing room sending a mob into empty space because it receives no confirmation of mob receipt, etc).</p>
    <p>Manipulation will be much easier than this. A mob should be able to get, drop, and check its inventory of objects. That's it. When something is picked up, it should be removed from the location's inventory. When it is dropped it should be added to the location and removed from the mob. Not too hard a task, but one which once again must be synchronous to prevent weird cases where a location is just adding random objects to itself based on asynchronous receipt of old messages. Making this synchronous also means that two mobs can't get the same thing at once and accidentally dupe it in the process, because the location will block on the pickup message, remove the object, and then handle the other mob's get action message.</p>
    <p>Chat would be hard to implement if it were synchronous. But it won't be. Ha ha! We'll just be simple for now and fire chat messages off into space and assume everything works out. With a bazillion chat messages flying at once I don't really care if one gets lost, and it won't crash the game system. Anyway, the Erlang runtime guarantees delivery of a message so long as its target is alive, and that is really all we care about. This promise is actually quite amazing, and makes it very simple to create things like chat systems. But the chat system is not critical to the game world, just the users. I want to focus on making the world work first, then the chat system, so that's what I'll do.</p>
    <h3 id="controllers">Mob Controllers</h3>
    <p>Yikes! Network and AI code in the same spot!</p>
    <h3 id="mobman">Mob Manager</h3>
    <h1 id="scaffolding">Scaffolding</h1>
    <h2 id="telnet">Telnet interface</h2>
    <p>MUDs traditionally work over telnet and do not require any special client-side software. We will follow this tradition in ErlMUD, at least for a while. It is common for clients to be written that understand a particular MUD or MUD family's textual structure, commands, alias system and map representation, and simply use the telnet protocol to connect on behalf of the user. Using TCP sockets is easy enough in Erlang compared to C that its tempting to break with tradition and just write a new TCP protocol and a client and server of our own on both ends. We're not going to do that, at least not yet. The reason is that telnet is easy, and easy is a good place to start when writing a new project with a design that is untried. I'm pretty sure I can get the internals of the main MUD elements to work, at least in a hackish way, without too much trouble. I'm also pretty sure that if I mess with it a bit I can host write a telnet server (should be a lot easier than doing it in C in the past). This is already a significant amount of work to do, and both are things I've never tried before. I don't want to add a new network protocol, a whole new application (the client software), an installer or package(s) for that client, and a way to get the client to users to the list of things on my plate just now. We're not even into the code yet. If any feature isn't absolutely essential we should consider if its something we might want to write it down, and then forget about it (hopefully forever).</p>
    <p>Telnet is a pretty simply protocol, but, as indicated above, may not be the only way we will connect to the MUD. Consider that even without client software we might want to be able to connect over a secure channel instead of Telnet, since Telnet is all plain text, including passwords (oh no!). So designing the system so that the telnet connection is a component that the main service manages, and not a bunch of networking code written directly into the main system loop, is a good idea. That gives us options, and even if we never exercise the option to connect through some other method (consider how nice it would be to connect directly from an Erlang shell on another node...), it will force us to do the right thing early on and separate the detail of how we connect to the network from the fact that we connect to the network.</p>
    <h4 id="chat">Chat system</h4>
    <p>Chat is one of those things that isn't arbitrated by locations, globally accessible, and not an option. There are a few things we have to think about when implementing a chat system. For one thing, each location is sort of its own little chat server, since all verbal and emote activity is visible to other occupants. We might want to implement something like a "shout" feature, where any really loud action (like an actual shout) can be heard to all occupants of locations within a zone, or maybe heard X-locations away. We might also want to mimic a fun feature of WoTMUD, where players of two different species can only understand their own kind but still share basically the same channels.</p>
    <p>Channels? Hrmmm. That's a lot like locations again. So the real question is, how do we prevent ourselves from duplicating a ton of code? Another issue is whether a mob joins a channel, a controller joins a channel or a player's connection handler farther up the stack joins the channel (and is the player's connection the same as the controller?). Previously we had established that mobs require controllers and that separating controlling logic/interfaces and the mobs themselves is probably a good idea. Now we come to the question of "what part of a mob has ears and eyes?". I think it makes the most sense to give the mobs themselves the sensory organs, route chat messages along to the controller the same way other observations are, and let the controllers handle or disregard messages as needed. Then I can avoid writing any special case code into "chat listeners".</p>
    <p>What about private messages, like "whisper" or "tell" features? Its easy enough to implement a "tell" that makes one mob send a chat message directly to another mob, bypassing anything else. We can even say that each mob maintains its own "ignore" list and avoid having to write a central nanny message arbitration function. But this issue with ignores, private messages, channels, listening for shouts, emotes, verbals, etc. is already demonstrating that chat is actually not such a simple part of the game, simply because targetting, routing, listening and filtering are all issues we start having to suddenly deal with.</p>
    <p>Actually, I don't want to put this into the mob's core logic. I really want to just have a single message tag, like <code>{chat, From, Message}</code> and have <code>Message</code> contain the message itself and a meta message that we can perform filter, routing, etc. logic on. And I don't want to write that logic into the actual mob processes themselves, because I'm pretty sure the metabolism and combat system is going to fill quite enough lines of code as it is. So we should write a second, assistance module for mobs that behaves like their sensory organ. Chats can either target that directly, or target the mob and the mob pass its message into it asynchronously (this is the kind of process I would link, so its logically a part of the mob, and if either crashes the whole mob crashes), and the sensory process can take over from there.</p>
    <p>We need to write a system of channels which can be created, joined, left, and moderated. This will probably look a bit like the way locations are implemented, but without all the extra logic of physical arbitration, travel, or anything else hard. We don't need a map, either, but we may want to define some boundary conditions for chat channels, like default instantiation of factional or race-based chat rooms or something of that sort. To begin with, though, we should probably aim low and write a single global chat channel, then once we understand that, add another, and then add an in-game way to identify who should automatically belong to faction-type channels, and make a way for players to create channels in-game as well.</p>
    <p>So that's the plan for now: first get a simple, global broadcast type chat working, and diversify from there based on whatever features we decide to implement later on. At first, anyway, with zero or very few players we won't really need to do much with channels, so we can keep in mind that we want to implement channels later on, but skip doing anything with that idea for now.</p>
    <h4 id="player">Player registry</h4>
    <p>People have to have some way of identifying themselves to the game server so that it can locate their character. Or not. We might want to design a game world where every time you log in you randomly inhabit a pre-existing mob and engage in whatever is going on nearby on your own. This is actually a pretty interesting idea, so I'll write it down, but for now I'm going to do the old-fashioned (and not very secure) username/password way of doing things.</p>
    <p>But do players have accounts and characters, or is every character an account? Mobs will certainly have some concept of points or level status or something, but is this different than an account system or is the character system itself all there is to the account system? I like the free feeling old MUDs give by making characters painless to create and totally independent of one another with no account system above this. On the other hand, players today are pretty used to the World of Warcraft account model where one account owns several characters. The problem there, of course, is that if your account gets compromised all your characters are compromised at once. Its a player-side version of putting all one's eggs in one basket, which is good to avoid. Perhaps a good middleground is possible, where we create an account system, where each account owns only one character, but make it possible to add additional characters later on, but just not implement the command functionality for that yet.That means we need player accounts, and they need to track what mobs they own.</p>
    <p>So that's two things to implement: a storage system for persistent character data (whatever the system remembers of you when you "rent" or logout), and an account storage system for tracking account/character relationships.</p>
    <h4 id="erlmud_start">erlmud:start/0</h4>
    <p>Any system needs a way to get started. Some folks write this module in as much detail as they can first, and then work from there down to the details. Some folks work on the tiny components first, assembling their code from little blocks as they go. I mostly do the top-down part, but don't spend much time on detail at the highest level. Instead I usually write a <code>somapp:start/0</code> function that barely suffices to spawn a unique process, and then revise from there as I go. I've decided that this prevents me wasting time on too much detail that I don't have any hope of understanding just yet. It also allows me to be lazy at the high level and geek out at whatever level of the problem interests me first, so long as I am diligent enough to fill in the execution path between <code>start</code> and whatever I'm working on.</p>
    <p>This is one place that it can be good to start trying to iron out the verbiage of your project very early on. Write your initialization bits in a way that deals with your major system components at the level of abstraction you want the rest of the world to. Starting this early on forces pushing details to other modules, particularly in the case of whatever data models are used to start up the system. The last thing we want is for whoever configures the system and might actually deal with some top-level component to have to know that object state is represented as a tuple of form X underneath. Yuk.</p>
    <p>I'm going to leave this one wide open for now, and only implement a direct code path that spins up the application and phrase things in the initialization procedure in a way I think is natural. It will probably be wrong, or at least not look much like whatever the production version of this module will look like, but that's OK for now.</p>
    <h3 id="unseen">That which is unseen</h3>
    <p>In thinking through the three main elements of the MUD some indications that a three-module codebase was going to be insufficient. When discussing locations we mentioned that locations have quite a few more responsibilities than their imperatively implemented counterparts do, and while we're sure that locations will be required to handle some message broadcasting (notifications to everyone in the location), directory lookups (who or what is in the location), and respond to basic queries (give the room description, name, etc.), we left open the non-trivial question of how locations are to  be interconnected. When discussing objects and mobs a list of attribute descriptions was given for mobs, but not for objects. What objects can "do" (if they can do anything) and what mobs can do, and where some crossover may exist was never addressed. In particular, we never developed a concept for how a world object that is not a mob might behave. Ultimately, we have no idea about how to implement time-decaying foods, traps, or anything else of that nature. The trap case is discussed below as an example. The discussion about mobs also touched on a very important subject: the mob controllers. These issues and complications arising from them, will be discussed in more detail below.</p>
    <h4 id="traps">Traps</h4>
    <p>At the beginning of the <a href="./001-001_concept.html#mobs">Mobs</a> section above I listed a series of descriptive qualities that mobs might have. Throwing out so many descriptions in terms of possible actions, adjectives and influences is useful to shape our thinking about the game world. For example, above I wrote "attack" but did not write "cast a spell". We should consider whether, for example, we want to include traps within the game world, and if so what sort of mechanism makes a trap work, and whether a trap is attacking, casting a spell, or acting on its victim by some entirely different mechanism. In short, we have to determine whether a trap is a "stationary mob", a mechanic governed by its hosting location, or some independent means that will require a new module that defines a trap as its own process. It is not particularly important at this stage whether we decide to include traps or not, but that we consider how to design a system in which traps are not impossibly difficult to implement.</p>
    <h2 id="thoughts">Thoughts on implementation</h2>
    <p>At this point we have a firm enough idea about how the primary <em>game</em> elements could be sketched out in pseudo code (or crayon, for that matter), but the elements of the<em>system</em> have not yet been addressed at all. How does the system start? What do we call? How do we contact it? Where do locations, objects and mobs come from in the first place?</p>
    <p>Our initial goal will be to create some very basic components that conform to the main elements of the game platform as described above: locations, objects and mobs. As mentioned, will need a way to start the system up, a way to manager for each type of element that will probably evolve into a supervisor or supervision tree, and a few other elements. But we won't really care about that stuff to begin with. Our first goal is to simply create a 3-part system that can behave as a very basic game platform. We don't care about gameplay mechanics yet, we don't care what the world looks like right now, and we don't care that the only thing we can do in the world is move around, talk, emote, chat, and pick things up and put things down. Until we create a general basis for the world's most basic mechanics thinking too much about anything else is just pipedreaming, and while exploring the system you ultimately want to build in your mind can help you come up with good ideas, too much of that without enough actual code to back it up just leads to wasted time and premature project death.</p>
  </div>
  <div id="footer">
    <div id="nav"><a href="000-001_introduction.html">&lt; Previous</a></div>
    <div id="nav"><a href="index.html">Home</a></div>
    <div id="nav"><a href="001-001_concept.html">Next &gt;</a></div>
  </div>
</body>
</html>
