<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" />
  <title>ErlMUD Notes: Concept | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="concepts">Concept</h1>
    <p>ErlMUD is a simple Multi-User Dungeon written in Erlang. It is written in a way that takes advantage of Erlang's concurrent, strict message-passing model and the few promises provided by the Erlang runtime.</p>
    <p>This commentary follows the development process of ErlMUD as it undergoes changes, feature additions and design evolutions. The code is written several times iteratively, gradually adding features and — most importantly for the purpose of this project — evolving in terms of code style from a primitive system of limited functionality to a full-blown production system that would (hopefully) not drive future maintainers mad.</p>
    <p>This chapter begins by discussing some aspects of design that are common to any project, details the primary elements necessary to create a MUD game world, and then discusses each element in turn and whatever secondary, "unseen" aspects become apparent as necessary for implementation. The purpose of this section is not to hash out every detail in prose, but rather to think about the problem in a general way and discover some of the unobvious issues that will have to be dealt with. The goal of the implementation is to elevate the primary game elements to the level of abstraction that we want so developers, system operators and players can dispense with the details.</p>
    <h1 id="elements">Elements</h1>
    <p>In any project there are two categories of elements. There are those which obviously must be a part of the design and those that require discovery on the part of the developer.</p>
    <p>The obvious parts are clear to us either because they represent a resource we know is required beforehand or because interacting with these elements is the purpose of the program. At the outset of the project this is what is seen.</p>
    <p>There are other elements, however, which are not so obvious and must be discovered through exploration and experimentation. The exploration part involves working through the problem space, discovering exactly what the problem implies in terms of logical components. The experimentation part consists of trying different methods to handle the problem and evaluating the resulting system by some balance of criteria to determine the "right" design (or, more often, the "least wrong" design). As the problem is explored and little experiments progress developers will come to the inevitable realization that handling the problem is not as easy as it initially appeared, that too much understanding of the problem was assumed, and that previously unconceived elements are necessary. At the outset of the project this is what is not seen.</p>
    <p>The "seen" bits represent a basic description of the problem and the "unseen" bits represent their implementation. This is analogous to the difference between reading the definition of a square root and coming up with an algorithm to derive them. Erlang is a very high level language in many respects, but it is not so advanced that we can simply plug in a mic and demand "Make me a system that does X!" and get what we want.</p>
    <p>When writing software for ourselves we usually know what features we want and can quickly enumerate the "seen" bits; it is our lack of understanding of the unseen bits (or rather our naïve assumption that we do understand them) that bites us in the ass. When writing software for customers, however, the most frequent problem is that the customers are themselves not able to "see" the parts that should be initially "seeable".</p>
    <p>Projects must evolve as they move forward to cover the distance between between the early, intuitive understanding of the primary elements of a system and the unobvious bits necessary to implement them. Sometimes an "evolution" means tweaking an interface or adding some method of type checking to catch mistakes early, sometimes it means radically changing a data schema, and sometimes it means a general re-write because we discover that a current approach is not working (or that it works, but is too costly to pursue). A change of a few characters may represent a huge change of semantics, and a change of several hundred lines may represent a minor change in approach. We will see a broad range of evolutions as ErlMUD grows.</p>
    <h1 id="process">The process</h1>
    <p>How do we know what elements we will need? How do we discover the "unseen" bits? What part should we try to write first? How do we know what we're trying to do?</p>
    <p>There is an entire cottage industry built around trying to sell software development methodologies. They are all crap. I won't pretend to do any of that here. There is no One True Way; you will ever be learning and improving your own methods. "Computer Science" is still not a science and its only beginning to dawn on us that it isn't really about computers anyway.</p>
    <p>In the absence of a methodology to follow I'm going to be a bit of a traditionalist and commit to an early top-down approach to the problem of system design. This should work out reasonably well for two reasons: we already have a huge headstart understanding what MUDs are (we can refer to examples in the wild); and the point of ErlMUD is to demonstrate Erlang styles, not obsess about methodology. Even if I have to go a bit further into "big design up front" mode than I normally would, there is a great value in being able to explain the system we want early on so that I can focus on the real purpose of this commentary.</p>
    <p>Once we do the big conceptual design bits in informal prose we'll tighten things up with a summary and think through some of the details of whatever message protocols we require. When it comes to actual coding, though, we'll skip around the scales of abstraction a bit, working some at the top and some at the bottom until we eventually mesh the two together into a working system. I don't know any other way to write an "actor model" or "concurrency oriented" system than to start writing some actors or concurrent processes. I think this is a fairly ordinary way of writing Erlang code, and I don't think it adheres to any official methodology. But that is unimportant.</p>
    <p>We will describe the problem in a general way then see if we can pick apart the conceptual pieces of it and segregate them into mechanical bits. The conceptual pieces represent our intuitions about the system, the parts that are initially obvious which sit toward the top of the abstraction. The mechanical bits will constitute the next layer downward in the abstraction, the first big chunks of implementation.</p>
    <h2 id="problem">The Problem</h2>
    <p>"Write a MUD."</p>
    <p>Well, that was easy. It sounds simple when stated that way but it doesn't give us much guidance on how to go about it. What can we break that down into? If we take it at face value then its OK to hard-code world mechanics, a gameplay system, even game world and character data right into the source of the project. Yikes! That would be a nightmare. How do we avoid this?</p>
    <p>We can split almost any piece of software into three general pieces:
    <ul>
      <li>a platform or logical engine</li>
      <li>some operating rules</li>
      <li>instance data to operate on</li>
    </ul>
    <p>(Don't worry, this isn't a practical joke where we actually write a MUD in COBOL! Yay, code divisions...)</p>
    <p>Consider a text editor: there is the editor program itself that manages the widow and user interface; there are contextual rules like settings, a plugin system, modes, and so on; and there is the text data users are actually interested in. Now consider a browser: there is the browser itself that manages the window, socket connections, etc.; there are operating rules like plugins, scripting languages, rendering engines, download managers, email subsystems, ftp clients, and whatever other clutter; and then there are the web pages that users actually want to see.</p>
    <p>Not every piece of software is structured like this, but most of them are. Even rather small programs often work this way. Think about the programs included in <a href="http://www.gnu.org/software/coreutils/" title="http://www.gnu.org/software/coreutils/">GNU coreutils</a>, for example (cat, wc, ls, tail, etc.). Nearly all of them have a core routine (logical engine), a switch or script interpretation system (operating rules), and input data to operate on (instance data). Most of the time when you run across a program that doesn't follow this form you're looking at an early alpha, a convoluted codebase, or a throwaway program. MUDs run for years, sometimes decades, so we shouldn't commit to a design where these concerns are tightly coupled. (This isn't the kind of system where job security is a design requirement...)</p>
    <p>A MUD system needs a world simulation platform, rules that define the gameplay, and world data. That means we need to identify what a MUD requires from a world simulator, create a way to define a gameplay system, and create a way to define game entities. Before we can break the system apart into these pieces, however, we need to understand what a MUD is from a user's perspective.</p>
    <h3 id="definition">Definition</h3>
    <p>"MUD" stands for "Multi-User Dungeon". MUDs are multiplayer adventure games, usually accessible via telnet or ssh, and generally provide a line-based text interface. Locations in MUDs are defined as "rooms" or "sectors" which are often grouped into "zones" which share some common behavior. Entities in MUDs are animate "mobiles" (or "mobs") and inanimate "objects". A player character is represented as a mob which is under a user's direct control. An arbitrary range of movement methods between locations is defined, often unique to each game system, and an arbitrary range of interactions is defined between animate→animate and animate→inanimate entities.</p>
    <p>Combat is often a strong component of a game world, but in some MUDs chat, emotive actions or roleplay is the focus. In any MUD, whether combat or roleplay based, there is a strong user expectation of community involvement. The primary motivation of most MUD players is themed interaction with an online community, not mere interaction with the game world itself. Many MUDs run for decades with the same general player base and are expected to be generally stable for as long. Most MUD systems are usable as backends for either combat/adventure or chat/social servers. In a certain sense MUDs can be thought of as super-advanced chat servers, though it seems that most MUD authors do not think of them in this way.</p>
    <h3 id="platform">The Platform: A World Simulator</h3>
    <p>A world simulation is primarily concerned with geography and basic physical laws. In this case our geography is our location layout and our physics are the rules of entity interactions among themselves and among locations. In any conceivable MUD some mechanism must be provided to make travel between locations and interactions among elements in the same location possible. Locations must also have knowledge of their relationship to one another, and what objects and mobs are present at a given time. Also, there must be some way for locations to interpret map data so they can derive their relationships with one another.</p>
    <p>We'll probably find a few other things that the world engine should be responsible for, like maybe some concept of a universal timer, but in general anything that falls outside these areas are not responsibilities of the platform itself and fall to the level of gameplay or data issues. Consider for a moment what that means in terms of what the world simulator doesn't care about.</p>
    <p>The world doesn't care if mobs turn out to be ships in a space-trader, adventurers in a dungeon crawler, techno-dinosaurs questing for evolution juice, or whatever (gameplay issues). The world doesn't care if objects are valuable in a trade system, prone to decay over time, lockable containers, proximity traps, or anything else (also gameplay issues). The world doesn't care how players accrue points or experience or rank, or whether everything in the world is completely temporal (intersection of gameplay and data issues). The world doesn't even care if the map is randomly generated each instance, is a static game map definition, or is some wacky bendy concept of higher-dimensional space in a Lewis Carrol sort of game world (map storage, retrieval and generation are data issues).</p>
    <p>We can already see that our simulation platform is rather intimate with locations, but not as much with objects or mobs. The world must provide a basic interface between locations and objects and locations and mobs, but shouldn't care what form the objects and mobs take internally. This is easy, since it means all we need is a messaging protocol that objects and mobs can use to interface with the world. The concept of chat is still up in the air, but aside from mobs talking to other mobs in the same location it is likely that any global chat system will probably also fall outside the scope of the world simulation as well.</p>
    <h3 id="operating_rules">Operating Rules: A Gameplay System</h3>
    <p>By separating the world from the gameplay we have avoided committing the world simulation to any particular game system. Any system of locations could serve as a platform for any system of entities (objects and mobs), so long as the parts conform to whatever message protocol we develop. In other words, we could design a grid world of locations and atop that implement shogi, chess or checkers.</p>
    <p>The shogi/chess/checkers example is interesting to explore to discover some implications of this decoupled design. Consider how the separation of the pieces from the board means that each different set of pieces defines a different game, and this is true independent of the nature of the board or game world. For us this means that to write a different game we have to actually code different pieces. Another other thing of note is that different styles of play — different variations of the same game — can be built by changing the valuation or balance of a given set of pieces. This applies to our MUD system as well: without coding new entities we can tweak the game by altering the balance of inputs to the rule mechanics. As we code the game we need to note places where we are tempted to code magic numbers into rule, game mechanics and entity code and always provide a way to insert any hard numeric values as balance settings instead. In other words, game balance is a data issue and entity definitions are gameplay issues.</p>
    <p>One somewhat surprising outcome is that the exact same engine and rule-set could be used to implement multi-dimensional versions of shogi, chess or checkers simply by changing the map (data) to something other than a flat grid without making any changes to the piece code or the game rules. We could make <a href="http://wiki.classictw.com/index.php?title=Main_Page" title="TradeWars 2002">ship-trader</a>,  <a href="http://www.wotmud.org" title="WoTMUD">D&amp;D</a>, <a href="http://www.bandainamcogames.co.jp/cs/list/batenkaitos/battle/index.html" title="Baten Kaitos">card-battle</a>, <a href="http://breakintochat.com/wiki/Operation_Overkill_II" title="Operation Overkill II">world-map/combat-timer</a>, <a href="http://www.mobygames.com/game/dos/pit_/screenshots" title="The Pit">sprite/glyph collision combat</a>, <a href="https://www.usurper.info/" title="Usurper">random encounter</a>, <a href="http://rephial.org/" title="Angband">dungeon-crawler</a>, or whatever other gameplay we might imagine occur atop a chess board by swapping the pieces and keeping the chess map data. Of course, in the example case used in this commentary we are building a traditional D&amp;D inspired MUD, but don't let that stop you from experimenting in wild directions.</p>
    <p>This business of separating the world engine from the rules is rarely done, mainly because the difference between the world as a platform and the gameplay as a mechanical system is usually not considered by game authors as they begin their design task. Part of the reason is that game design is a skill that is usually practiced under duress. Business pressure, Christmas deadlines, the deferred rush for an American school break release, the company being acquired by new owners that know nothing about games or software, a culture that confuses typing with development, and any number of other human or organizational weaknesses often conspire to detract from the task of understanding how the world, entity behavior and entity balance of a game system work together.</p>
    <h3 id="instance_data">Instance Data: Maps and Items and Characters Oh my!</h3>
    <p>A world system plus a set of entity definitions results in a complete game system but not a complete game. We need data that tells a particular game system what game it should manifest. There are two categories of game data: base data and instance data. Things like maps, NPC data, script defaults, item locations, container quantities, prices, NPCs, spawn points, balance settings, etc. are all base data. Data that represents the current state of the world like current character stats, player account information, current locations, inventory levels, etc. are all instance data. Any instance of a game is going to be a unique combination of base data and instance data.</p>
    <p>We have to decide how to prioritize the data points we will be dealing with and determine what is worth putting into persistent storage and what is OK to lose in memory if the whole system dies or needs to be restarted by the operator. We also have to decide how the game system will save data and in what format, and more importantly, how operators who want to create a unique game world will populate their own maps, objects and mobs with whatever template entities we provide as part of the system.</p>
    <p>Different game worlds might have radically different themes. If we do a good job writing ErlMUD then a system operator who wants to set up an ErlMUD server won't need to know Erlang, the details of telnet or TCP, the vagaries of OTP or any other forms of modern magic. Anyone who wants to set up a basic server should be able to imagine a game compatible with the default world and entity definitions and express the game world they want without messing about with these things. One ErlMUD based world might be a Tolkien-like place full of goblins, warriors, elf princesses or whatever else, another might be a postapocalyptic world of survivors, mutants and zombies set far in the future, and another might be a Western full of dangerous outlaws living in the Badlands of Cyber New Mexico. Writing new entity definitions (making significant changes to gameplay), on the other hand, would be an advanced setup but should be a relatively straight forward task given the necessary Erlang/OTP skills.</p>
    <p>One consideration with the building of worlds is whether we should build tools for creating the world, a facility for world creation within the MUD itself (a specially priviledged player being able to spawn rooms and things on the fly), or just let the sysops deal directly with text files that contain settings information. Right now it doesn't really matter, but this will be something to consider later on. The easier it is for a sysop to express what they want the better we are doing in building a system that users will actually care about.</p>
    <h1 id="distillation">Distilling Elements</h1>
    <p>From the discussion above, and from taking some time out to play a MUD or two (seriously, try one), we can see that the top levels of the problem "write a MUD" are:</p>
    <ul>
      <li>platform</li>
      <ul>
        <li>locations</li>
        <li>location-location message protocol</li>
        <li>location-entity message protocol</li>
      </ul>
      <li>gameplay</li>
      <ul>
        <li>entities</li>
        <ul>
          <li>objects</li>
          <li>mobs</li>
        </ul>
        <li>interaction</li>
        <ul>
          <li>procedures</li>
          <li>rules</li>
        </ul>
        <li>independent systems</li>
        <ul>
          <li>scoring</li>
          <li>ranking</li>
          <li>competition/ladder</li>
          <li>minigames</li>
          <li>alternate play modes</li>
        </ul>
      </ul>
      <li>data</li>
      <ul>
        <li>base</li>
        <ul>
          <li>maps</li>
          <li>entity</li>
          <li>spawn</li>
          <li>balance</li>
          <li>data generators</li>
          <li>data editors</li>
        </ul>
        <li>instance</li>
        <ul>
          <li>entity condition</li>
          <li>entity location</li>
          <li>accounts</li>
        </ul>
      </ul>
    </ul>
    <p>We've discussed the game system, but not the scaffolding necessary to spin things up. We'll go into more detail about this later on, but for now some obviously necessary system elements are:</p>
    <ul>
      <li>network interface</li>
      <li>chat system</li>
      <li><code>erlmud:start/0</code> — it has to go somewhere!</li>
    </ul>
    <p>So far, this is what we can see. Next we will take a closer look at the game elements and system scaffolding and think through what supporting elements we might need to implement.</p>
    <h1 id="game_elements">Game Elements</h1>
    <p>Now that we have identified the role each element of the game serves we can think more clearly about how to implement them. Our goal is to avoid putting too much responsibility (really, too much complex behavior) into a single part of the system. The last thing we want to do is accidentally mix platform and gameplay concerns or sprinkle bits of data or rule systems into our element or simulation mechanics.</p>
    <p>To avoid either hard-coding a value into a process or forcing too much intimacy between two modules we will often need to write auxiliary processes or modules to handle a specific aspect of a certain game element's duties. It is common for a non-trivial system to not just be a system of independent processes, but for each meta element of a system to itself be a gruppe of linked processes which function together to accomplish a single conceptual task. In terms of Erlang we will find that Erlang's system of links, monitors and system processes (where <code>trap_exit</code> is <code>true</code>) are not merely convenient in demonstrating certain programming concepts, they are the very cables and mortar that let us build and segregate complex parts of a large system without letting any individual piece grow too complex to understand.</p>
    <p>Above we discussed some general insights into software and how those can be applied to the specific case of game system designs which require world simulation. That discussion could apply to a system written in assembler, C, Lisp, C++, Erlang or whatever. What follows is a detailed description of each game element (locations, objects and mobs) as it applies to a D&amp;D style MUD game world, and some thoughts about how we might implement them in Erlang. From this point on "game world" is assumed to mean "a MUD" and "implementation" is assumed to mean "written in Erlang".</p>
    <h2 id="locations">Locations</h2>
    <p>A location is a self-contained place within the game world where actions which immediately affect mobs take place. Our guildeline is that if a mob performs a physical, verbal, or emotive ("emote") action it should only be visible to or have a direct effect on another mob in the same location. This should be distinct from the chat system and probably most other actions that can occur at a distance.</p>
    <p>There are two basic ways to implement locations. They could be entries in a universal registry where mobs, objects and associations among locations can be tracked in tables. Alternatively, they could be processes which do their own entity tracking and are directly responsible for arbitration of physical actions.</p>
    <p>If we use a global-registry then we have the problem that nearly every action in the world depends on this registry. If this were a single process it would be a pretty busy one, but guaranteeing consistency would be relatively simple. If it were a worker pool the load could be distributed, but consistency would be much more difficult to guarantee and the registry store itself would still be a bottleneck. Either way, we would be putting all our eggs in one basket. If this registry were to die so would the MUD. This goes against the principle of fault tolerance and is precisely the sort of thing Erlang was designed to avoid.</p>
    <p>Fault-tolerance aside, consider how complex such a monster registry would become. Once we give too much responsibility to a single piece of code the tendency is to increase the number of responsibilities it handles over time. This is against every good practice we know as developers, but under the pressures of real life, business, and expectant users this is what tends to happen. It is quicker to hack "just one more" feature into an already overloaded system than to sort out the tangle of preexisting responsibilities and then implement an additional feature orthogonally. One Registry To Rule Them All is actually a pretty normal design in an OOP or imperative style MUD, but I don't think its a good fit for Erlang.</p>
    <p>The other way, where each location is a process, seems more sensible to me. If locations are processes then we avoid creating any bottlenecks and crashes can occur at a small enough scale that we can probably recover without causing a MUD-wide crisis. This design is also easier for me to reason about because it is closer to being a genuine simulation of a world. This is the way we will try first.</p>
    <p>Each location will need to keep track of whatever mobs, objects and connections to other locations are present. If a mob, object or adjacent location crashes the location should be notified but carry on. The location's job is to arbitrate activity within the location (someone closes a door, drops an item, mob attacks mob, etc.), answer queries about its current state (who/what is here, what exits are available, etc.), and broadcast location-wide notifications (a mob enters the room, says something out-loud, etc.). This is a fairly simple list of responsibilities that we can probably model in a single process without getting confused.</p>
    <p>There is a lingering problem, though. Locations will need to track the status of adjacent locations and arbitrate the movement of mobs between themselves and those other places. This means two identical processes will have to communicate, and this communication will need to be synchronous. That means we need to watch out for deadlocks. Anytime two identical process communicate synchronously this can happen because they both have procedurally and semantically identical "send foo, then listen for bar..." steps which can get out of sync (if they both "send foo" at exactly the same time, for example). Oh noes!</p>
    <p>My way of avoiding this kind of deadlock is usually to create another type of process that takes care of the synchronous communication on behalf of one of the two principal processes. This lets me design a protocol that at least isn't guaranteed to have a deadlock built in. Whether our protocol actually avoids deadlocks is a different issue, but this way at least we're not certain to have one.</p>
    <p>In this case I think it makes sense to create a "way" process that represents a one-way path between two locations. This lets us create interesting maps without adding new logic to the locations themselves (one-way portals, for example), and a method for implementing other game elements like shuttable/lockable doors, hidden paths, temporary portals, fuel-operated warp gateways, or whatever. Separating the idea of a "way" from a "location" gives us a lot of advantages both in terms of modeling the game world and in preventing kinks from emerging in our messaging protocol.</p>
    <p>Something we glossed over up to now is how to instantiate the locations. Where do they come from? Since we will probably have a map defined in permanent storage that gets pulled during startup or reload a traditional worker supervisor will probably be a good fit. We can assume, then, that we'll probably need at least a "location manager" process that spawns locations and restarts them if they die untimely deaths. There might be other things we want a manager to do, like alter the map dynamically, but we don't have to worry with that for now. At this point it is sufficient to say that our second "unseen" element is a location manager that supervises the locations and that the locations are workers at the bottom of the supervision tree.</p>
    <p>So there we have it, we've identified our first "unseen" elements: ways and location managers. Let's take a closer look at these and see if they reveal any more necessary components we have been blind to up to now.</p>
    <h3 id="locman">Location Manager</h3>
    <p>Our locations have to come from somewhere and to do that the location manager has to know what locations to create and how they are supposed to be connected. That means we have to think about how we want to represent the map data in Erlang terms. We'll worry with the details of that later when we actually start hacking around on a prototype location manager. What is important now is that we create a clear distinction between using data and manipulating data.</p>
    <p>So what should our location manager not do? It should not generate, store or edit map data; some other part of the system should be responsible for those things. Its probably not even a good idea to make the location manager know how to read map files directly, as we still don't know anything about how we're going to store the map data (files or a database or some map data service?). It is best to completely separate marshalled data tasks, everything to do with touching it in an external representation, from the task of turning a map file into an Erlang term that represents a map.</p>
    <p>But wait! Now is a good time to stop and remember the YAGNI principle: You Ain't Gonna Need It.</p>
    <p>We don't even have a working system yet and I'm postulating the future existence of data services. It is absolutely important that we consider the distinction between data operations and operations on data, but it is also absolutely important that we don't waste an inordinate amount of time on things that we don't (and may never) need. We can't run off on a technical tangent and start writing database bindings just because we might need them in the future when what we need to spend our time on is getting a basic system working first. My preferred way to deal with this sort of thing is to wrap the concept of "retrieving data" into its own function and move on. Later, if we actually do wind up with a data service then we can change that function and make it do more interesting things without touching the rest of the location manager code.</p>
    <p>We've established that the location manager is not a data manager. So what, exactly are its responsibilities? At startup the location manager will get spawned as its own process by something higher up the system heirarchy. It will retrieve a definition of the world map and spawn each location as a linked process and trap their exits, passing to each whatever data is needed to function properly. It will then loop, keeping track of live locations against the initial map configuration, and restart dead locations as necessary.</p>
    <p>We may want to build some more features into the location manager as we go, like maybe a way to ask for the pid of a location at some particular coordiate or location ID, but the above is the basic gist of what we want a location manager to do.</p>
    <h3 id="ways">Ways</h3>
    <p>We recognized earlier that locations would have to arbitrate the movement of mobs around the map and that this would require synchronous communication among locations. Our way of avoiding this is to create an intermediary that functions as a one-way path between two locations. This process can handle synchronous communication on behalf of one location and provide a way to elevate the message protocol from being symmetric synchronous to asymmetric synchronous. But how does movement arbitration work? Which "direction" does a way "point"? How do locations know which ways are relevant? How do they get started? How do we write ways so they are easy to understand and manage?</p>
    <p>The verbiage of ways can be a bit confusing. Each way is an exit from a location and an entrance to another. From the perspective of the way, however, its entrance is the departed location's exit, and the way's exit is the entrace to the location on the other side. To keep things straight I will mostly discuss ways from the perspective of the locations involved, not the ways themselves (but pay attenion). Ways logically extend locations, and can be considered part of the greater concept of locations.</p>
    <p>Ways are spawned by, linked to and considered an extension of the location on their exit side. In other words, ways are one-way entrances that belong to the location they provide a path toward. Exits from a location belong to whatever location is on the other side, and are monitored by the location they provide an exit from. If a way dies its location and all the other entrance ways to that location die as well. If an exit from a location dies the monitoring location knows that the attached location on the other side must have died as well and removes it from its list of available exits. There is no need to close an entering way if the location on the other side dies: the way can still exist, it will just be idle since no mobs can enter from a location that does not exist.</p>
    <p>When a location is spawned it will spawn and link its entrances. Way data includes the ID of the "in" and "out" locations on each side, and based on this the location can send an asynchronous message to adjacent locations with a list of its entrance ways so those locations can begin monitoring the newly spawned ways as available exits. The location will also ask for a list of what exits are supposed to be available to it and attempt to start monitoring them on its own. Because all locations both broadcast their exits to adjacent locations and attempt to monitor their own exits on startup we don't have to worry about the order of location or way spawning, because eventually all exits from all locations will be monitored either by request or by the autonomous action of the spawned location.</p>
    <p>Not so fast! We have a gap in functionality. Above I wrote that locations will request a list of the exits that should be available to it. Ask who? The location manager? Its got a complete picture of what locations exist and what the map should look like, so it could search through every location definition and find what exits should be available by checking every single entrance on the map. While it could do that this would be an ugly procedure if the data were left in pure map form, but we would be making the entire module ugly if we start adding a way registry to the system process that is supposed to be a location manager. It is much cleaner to instead create a "way manager" that keeps track of active ways and can be queried by "entrance" or "exit". To populate it with current data each way should register with the way manager as part of its initialization and the way manager should monitor each of the ways. The way manager is not a supervisor, though, and does not restart downed ways. It is just a simple utility for answering queries about ways. That's one more "unseen" element we hadn't thought about before: the way manager.</p>
    <h3 id="wayman">Way Manager</h3>
    <p>Why are we making a way manager instead of having locations act as their own way managers? The main irritation with this is the problem of data consistency. For each location to know its entrances and exits on startup it must be given that data. To do that either the location manager must receive separate way and location data and assemble them prior to spawning locations, or every location definition will have to maintain a copy of its own entrance and exit data. Because every location's entrance is another location's exit, this means that we will be duplicating data everywhere and that means we have to guarantee data consistency somehow. That sucks. If we are going to separate the location definitions from the way definitions anyway, we may as well have the way definitions managed by a queriable registry, and if we are going to do that we've already done all the work necessary for locations to determine their own way information by asking the registry.</p>
    <p>There are, of course, a few other ways to go about making way information available, but at the beginning here it is easier to write a way manager and skip designing any more message protocol pieces than to get clever. I'm much more worried about outsmarting myself early on than I am writing a slightly inefficient way registry process.</p>
<!--It would probably be a good thing to break out the crayons and draw a map of the different elements and the messages they pass among one another here.-->
    <h2 id="objects">Objects</h2>
    <p>Any inanimate thing in the world is an object: weapons, armor, consumables, light sources, money, clothing, food, containers, fountains, wagons, furniture, etc. Different types of objects may have special behaviors, like food that spoils over time, or a weapon that wears out or a piece of clothing that can only be worn on the head. Objects need a way of being created, destroyed, picked up, placed in containers, act as containers, used as ingredients or food, and any other in-game action we might come up with.</p>
    <p>This tells us that the design of objects is not simple and probably will not fit within a single module. Perhaps a food object should be defined differently than a weapon object, but adhere to a similar generic interface of "object". Maybe objects should be a central digest of dispatchable behaviors instead of being processes. We're not sure at this point, but it is certain that being able to interact with game-world objects in a natural way is a system requirement.</p>
    <p>I've got three basic ways in mind about how to implement objects. One is to make a central object registry that keeps track of all objects across the game world. Another is to have a library of object type definitions we can copy into a "live object" registry maintained by each interacting entity based on the type that is needed, and mobs, locations and container objects could pass the relevant data around to represent associations (passing an object would be passing the tuple that represents it). And yet another way is to make every object a process of its own, the way we do with locations.</p>
    <p>The central registry style suffers from the same problems a central location registry would, so that's out. If we thought a location registry would become a complexity monster and system bottleneck, imagine how beastly and busy an object registry would be! There is a lot less travel and position checking in a MUD than object-influenced activity (every combat action might take weapon and all clothing/armor stats and total carried weight into account, for example), not to mention the variety of behaviors that would have to be coded into the object registry to implement diverse things like ingredients, food, equipment, etc. No thanks.</p>
    <p>Passing references around seems a nice solution at first, but this isn't the way Erlang works: we can't share memory. The entire tuple representing the object would have to be passed between locations, mobs, and other objects as messages, and each of these process types would have to know how to interact with them. Passing would also be another case of mandatory synchronous messaging between potentially identical processes, and we already know that's inviting complexity. Incidentally, screwing up the procedure of passing pointers or creating/destroying structs/objects to represent item passing is the source of an entire category of game bugs. Most item "dupe" bugs and money exploits is rooted in some mishandling of item passing by reference or value.</p>
    <p>Naked data passing also breaks data encapsulation. If the shape of the object data ever changed that would cause a lot of surgery throughout several other modules. Record syntax could help us there a bit, but then we'd have to share record definitions across source files, and that gets wonky. (Actually, we'll see a version of this style once, and evolve away from it to point out why it is important to avoid.) A better way would be to wrap the object data behind a functional interface, and this might be a workable solution. But where would we put the influences of objects themselves? Let's say we want to implement food that decays over time. We will need to write some logic in location code that updates the state of the food it contains to effect the decay, and we will also need to write very similar logic into mobs and container objects to make sure the same things happen there as well. This would be true whether we wrote an ADT module to wrap the food data type or made the food tuple into an OOP-style object by including functions to operate on itself as parts of the tuple (bet you forgot that was possible!). No matter where those functions are something must call them, and since the data is tucked behind the encapsulation barrier that Erlang processes represent, those processes must do the calling. And where is the code for container objects now? This is actually not sounding like such a good idea. Its simple to think about passing a tuple that represents an object in the game world, but not so simple as soon as we want those objects to exhibit some sort of behavior of their own. We're obviously trying to cut against the grain of Erlang's runtime here.</p>
    <p>That leaves us with designing objects as their own processes. This gives us the freedom we desire and makes thinking about objects much more simple. We can code "object logic" directly into them and give them their own processing loops, timers, state, etc. But what about the different categories of objects? How do we make food, weapons and containers fit into the same definition? We might not be able to. I'm not so sure that all objects will fit into a single module, we may need several to keep our code simple and understandable. But that's OK, because there are no constraints on process type with regard to message passing.</p>
    <p>What we really need is a messaging protocol for objects. That way objects of a certain type can identify themselves if necessary, have their own behaviors with regard to messages received and sent, and all look basically the same from the outside despite their internal differences. This is essentially the actor model version of duck typing. An oven could be a finite state machine, a container a service process, and food could be some new "food behavior" we have yet to invent. The point of defining objects as a protocol and not some specific process type is that it permits us to defer the details of any particular object type until later. We can play with this protocol early on by creating some generic object type at the outset which will grow to represent our basic object message protocol, and keep in mind that implementing special object types will require new modules that adhere to the basic protocol. Of course, to design a protocol we have to determine what to talk about first, and that means we have to establish some basic attributes common to all objects.</p>
    <p>Note that we're suddenly in the actor version of type class definitions. We probably won't write a different module for every single weapon in the game, because that would suck. We will probably write a single weapon module that represents all weapons or maybe every weapon of a particular weapon category, and the data we plug into a spawned weapon will make it unique. We may use the Erlang concept of behaviors to ensure we don't screw up our object definitions, but that's an issue for a later time once we actually have a basic system working.</p>
    <p>Here we have two unseen elements: generic object attributes and the object messaging protocol. We knew at the beginning that we wanted to have objects in the game, but until now it wasn't clear that "objects" would have to be a category of process definitions which adhere to a messaging protocol as opposed to a single type of process or data structure.</p>
    <h3 id="object_attributes">Object Attributes</h3>
    <p>Here we want to iron out the attributes common to all objects in at least enough detail that we can write a basic system and demonstrate that it works. If we don't think through this part we'll never be able to create a coherent object protocol. Actually, our object protocol will be ridiculous at first no matter what, but it will at least be a solid foundation rather than a useless concept proof that leaves out critical elements (like forgetting that food has weight because we only thought of weight in the context of encumberance penalties for armor or whatever).</p>
    <p>Let's start with the way we think of objects in the real world to start our MUD world off on solid footing. Objects are made of matter. Matter takes up space and has mass. Mass means weight. Space means volume. We could work these into the game system without overcomplicating things. Or could we? If we implement volume we will also have to implement volume checks everywhere (object A is light enough, but not small enough to fit into container B, etc.). That's probably not so hard to do in code, but its a bit more detail than most gamers are used to troubling with (outside <a href="http://www.eveonline.com/" title="EVE Online">spreadsheets cleverly disguised as games</a>). Gameplay tradeoffs will definitely become more complex if we include volume considerations, which could be bad, but it could also result in interesting decisions/dilemmas for players. We shouldn't forget about this volume idea, but for now I just want to stick with weight as a basic property of objects.</p>
    <p>Objects also have to carry enough information to identify their category or ilk (weapon, food, chest, etc.), name, target aliases, and description. For example, a player targets a rock by calling it a "rock" but when he performs an examine or look action a more detailed description of the rock should be displayed. Descriptions are our only way of conveying anything about the game world to the players since we're not implementing any graphics.</p>
    <p>So there we have it, at least for now: objects have a category, a name, a set of aliases, a description and a weight. All objects exhibit these properties, regardless of type. We can implement a very primitive game world where this is true, and come back and make this more interesting a little later.</p>
    <h3 id="object_protocol">Object Messaging Protocol</h3>
    <p>The basic object protocol needs to be general enough that every object of any type can conform to it without making things ridiculous, but not so specific that it interferes with whatever unique things a special object type should do. There is no doubt that the protocol itself will have to get ironed out a bit as we go along, but a good place to start with building a message protocol is basic interrogation of the object's properties. This is something we have a head start on since we already decided what the most object attributes are.</p>
    <p>We're not going to get into the details of message construction here because the messages will change a lot as ErlMUD evolves from raw Erlang to OTP. What I want to establish now is the basic semantics of each message, and leave the details of how each message is built until later.</p>
    <p>Objects need to respond to inquiries about their current state. So far the only things they can answer are questions about their attributes. What else might objects need to send or receive messages about? Objects don't tell a location they have been placed there, whatever is doing the placing is responsible for that. Objects are not responsible for knowing their current location (this may need to change, but not yet). We currently lack a concept of in-game ownership (as in most <a href="http://www.uesp.net/wiki/Oblivion:Crime#Stealing" title="Stealing in Oblivion">Elder Scrolls</a> games), so possession equates to ownership. There really isn't anything else to do but create a way to ask an object about itself and receive an answer. A simple synchronous message makes sense, basically "tell me attribute X" and the object will respond with attribute X. We'll iron out ways of actually doing this in code later. The only other thing we are certain all objects will be doing with data is receiving their initial information when they are spawned.</p>
    <p>Wait. Spawned? What does that? Oh, darn. We need an object manager.</p>
    <p>So the object message protocol is mercifully simple and we've discovered another "unseen" element: the object manager.</p>
    <h3 id="objman">Object Manager</h3>
    <p>Objects have to come from somewhere, and where better than an object manager? The object manager will be started after the locations have been initialized, receive a list of what objects should exist, spawn each one in turn, and place it wherever it is supposed to load. The act of "placement" involves notifying the containing element that it is receiving an object, and the containing element must add it to its tracking inventory and confirm receipt to the object manager. Without sending a confirmation the object manager can't know whether the object is in inventory somewhere, accessible to the mechanics of gameplay, or effectively orphaned.</p>
    <p>The object manager's task is a bit more complex than the location or way managers. In particular, where to load objects is not a simple thing. A "load" could be in a location, a mob's inventory or in a container object's inventory. There may also be a world total for objects of type X or global ratio between two objects which have probability X::Y of loading in a particular spot, etc. For now we're going to make the loading task flat and boring, but keep in mind that object loads are usually not as simple as that in a game, especially when it comes to re-loading objects which have been destroyed or consumed.</p>
    <p>In addition to the non-trivial nature of object loads, the object manager is responsible for tracking live objects and restarting them if they crash, and notifying the containing element of the new identity of the recovered object. It is the object manager's job to rectify the situation if this happens in error, as with a crash. Objects must be monitored by their containing element and removed when they crash or are consumed.This responsibility goes the other direction as well. If a containing element crashes the objects it contained should either crash as well or notify the object manager of their situation lest the population of instantiated objects becomes unhinged from the game world. Our objects are so simple right now that its probably not possible for one to crash, but as specialized objects grow in behavioral complexity the liklihood for an object to crash will drastically increase.</p>
    <p>Because we can't know how complex the interactions between containing elements and contained objects might eventually become (perhaps a cursed item will cause a container to become explosively trapped or a magic item contributes a non-trivial buff to the mob holding it, etc.) we have to fall back on Erlang fundamentals. The purpose of "let it crash" and crash recovery is not to make a system that can't be damaged, it is to triage the damage so we can safely return to a known state. In this case, we can't be sure how complicated object interactions will become, so the safest thing to do is have containing objects kill their contained objects whenever they crash. So containers, whether locations, objects or mobs, should either link to their objects in inventory (so they all die together) or be monitored by the object manager so it can kill whatever else was contained. The simplest solution is to have everything die at once, and that means that if anything in a location dies, everything else in the location dies. This means bugs are location-wide grenades, but the catastrophe stops there. Objects, locations and mobs can follow whatever their respawn processes are without having to write a bunch of condition-checking code. Another advantage of the "kill it all" approach is that we are certain to notice this sort of thing, which means that bugs in the system will get flushed out into the open rather quickly, but without subjecting the entire MUD to collapse when something goes wrong.</p>
    <h2 id="mobs">Mobs</h2>
    <p>Finally, the focus of the game. Mobs are are the sentient denizens of the MUD and whereas objects may exhibit some behaviors, mobs initiate actions deliberately. They are the world creatures, the NPCs, the player avatars, the predators and the prey. Every beast, player, NPC, demon, perpetually kidnapped princess or whatever else we decide to include in the game world that is alive falls into this category. Anything that is attackable, killable, aggressive, prone to flee, talk-to-able, bound by in-game laws, factionalizable, grouppable, emotionally conscious, ownable as a pet, passengerable, or definable as friend or foe is a mob. Without them the MUD would be a pretty boring place.</p>
    <p>Knowing that all the above types of actions and attributes center around mobs indicates that, much like objects, while a general definition of mob may suffice at the outset they will likely define a category of modules rather than a single module that can do everything. Also like objects, mobs will require a basic message protocol that lets us write a variety of mob types that do different things but interact with the system in a similar way. The main difference is that while it wasn't so obvious at first that objects should be processes, it was always clear that mobs would be. In both cases we find ourselves settling on an initial, generic implementation of each so we can explore the message protocol in more detail, knowing that we will almost definitely be writing a few unique modules that adhere to that protocol later on.</p>
    <p>The similarities between objects and mobs only goes so far. Objects don't have volition so they don't have players or AI controlling them. Mobs do things. How do we make those actions happen? What determines what action happens when? If we put a dog mob somewhere, will he ever leave? Will he chase rabbits on his own? Where does that go? Do we re-write a new module every time we come up with a new mob type (and then have to change all thousand of them if we ever decide to change the mob messaging protocol? Ouch!)? Something is clearly missing here. We need a controller. Oh no, another "unseen" element!</p>
    <p>While it would certainly be possible to write the AI elements directly into a mob, that would pose some problems. For one thing, every mob would need different AI or else the world will be remarkably inflexible. Having an evil miniboss and the town blacksmith share the same AI would pose a problem. It also limits our options: what if we want to create a game world where all the mobs already pre-exist, and players just take control of mobs in place and play that way? Its not traditional, but its an exciting idea. What if game staff (usually called "immortals" or "imms") want to enhance roleplay possibilities temporarily by taking control of a village NPC and providing some live interaction? We can't do those things very easily if the controlling code and the mob code are intermixed. Well, to be specific, it might be possible to implement that sort of a system exactly once and never change it again, but smooth evolution of a codebase is one of the most important things we have to think about as developers and its no good to tie a big Gordian Knot of concerns right from the start (just because its what usually happens in the wild doesn't mean we have to make the same mistake).</p>
    <p>To perform actions mobs will have to know where to send messages that represent or initiate actions, be able to observe their situation, maintain an inventory, know what state they are in (awake, sleeping, in combat), and have some mechanism of determining the effects of received actions that may change their state. This mobs must have some way of being spawned, being hurt, being healed, dying, and being respawned.</p>
    <p>These are all either communication or internal state issues. Ineraction with anything not in its inventory means something in another element's inventory, and this requires a query to that containing entity prior to taking an action. Most of the time this mean's a location's inventory of objects, mobs or available exits, but there are exceptions with global systems like chat. Interaction with Anything in a mob's inventory first requires a lookup in the mob's internal inventory prior to taking an action. Any internal influences on a mob's actions require lookups into the current state of the mob's attributes prior to calculating the effect of the influence. That means we need to work out how these queries and lookups will work, and also need to decide what attributes mobs will have.</p>
    <p>Mobs are probably going to be the most complex things in the MUD. Not only are they extended by a controller and the player version of a controller will have to either include or connect to network code, mobs are also the only elements of the game that define direct actions and reactions with every other element in the game. Ouch. The basic procedures for accomplishing things within a mob are relatively simple, it is the variety of messages and actions that mobs must implement as part of their basic behavior that makes things complicated. To start with we will define a very minimal set of mob behaviors to make sure we're not going the wrong direction. As ErlMUD gains features it will naturally become a more complex system, but mobs, being the center of gameplay, will likely experience an explosion in complexity relative to other elements of the game. We will explore some ways to manage this complexity as ErlMUD evolves.</p>
    <h4 id="mob_attributes">Mob Attributes</h4>
    <p>We already know that mobs are the active force of the game and since we're writing a game system that implements a character-based D&amp;D style system that character traits are what determine the outcome of nearly every action. Mob attributes are not going to be simple. But we aren't yet concerned with implementing the game system in full just yet. We haven't discussed the combat system or weapon/skill calculations or anything else, but previously we identified that some or all of these aspects of the game can be at least partially wrapped up in minigames or temporary operating modes. In other words, we don't have to care about implementing every aspect of gameplay just yet.</p>
    <p>What we need to do before we think too hard about those other aspects of gameplay is to get a basic game world working where mobs can move around, talk to each other, use the chat system, manipulate basic objects, and be controlled by a basic AI or basic player controller. That's it. If we get these parts correct, implementing a combat system on top of it should not be hard. Good combat systems are hard enough to get right by themselves, so I don't even want to think about that until we've got a basic system functioning. Its really an orthogonal task, and one that will be a lot easier to focus on when the time comes if the world and the mobs in it already work.</p>
    <p>So what are basic mob attributes? Mobs will eventually require a rather extensive set of attributes and other state, but for now we're just trying to make them walk around without crashing. Its probably a good idea to stick with what we are familiar with and make them similar to basic object attributes for now: category, name, aliases, description and weight. Actually, we can leave weight off for now, because we don't care. If we don't care about a mobs D&amp;D style stats yet, we also don't care about the weight of it. At the moment we care more about what mobs do than what they are, so we'll just leave it at that, knowing we will definitely be filling mobs out a bit more later on.</p>
    <h3 id="mob_protocol">Mob Messaging Protocol</h3>
    <p>The mob protocol is a bit of a complex thing to discuss. The reason is that mobs are the hub of nearly all interaction in the game. Being the center of activity means that mobs define as many protocols as the number of unique sorts of activities they engage in. We should start with just the basics to permit a "live" game world to exist without getting too far down into the weeds.</p>
    <p>Let's see how minimal of a list we can come up with and still prove that the world works:</p>
    <ul>
      <li>movement</li>
      <li>observation</li>
      <li>get/put objects</li>
      <li>communcation</li>
    </ul>
    <p>That's it. We're leaving out all sorts of stuff like trade, combat, equipment, time, thieving, justice, etc. and just about every other conceivable gameplay element we might want later on. That's because we're just working on the most basic mob aspects right now not the advanced parts of gameplay (much less building an actual game on top of all that yet).</p>
    <p>Let's think through these for a moment. Movement is probably the most complicated thing to implement because it involves a collection of processes working together to accomplish a task. If we put a mob into a location and it wants to move, we need some way to indicate this to the location, then the location must check that the mob really is in the location, that the outgoing way is open, and then the way itself must let the receiving location know who is coming. The outgoing location needs to confirm that it dropped its record of the outgoing mob and the incoming location should acknowledge its receipt. We could combine the dropping from one location and confirmation of the drop without any issues (the mob doesn't care if it is locationless for a moment), and we can combine the incoming location's receipt of the mob with adding it to the new location's state. But this remains a non-simple chain of interactions to effect movement and it must be synchronous so that we can handle special cases in the future without encountering wacky corner asynchronous corner cases (like travel-related messages arriving really late, or the outgoing room sending a mob into empty space because it receives no confirmation of mob receipt, etc).</p>
    <p>What I'm really beating around the bush about is our need for a two-phase commit. We can cheat a little (failure in the MUD isn't the same as failure at a bank), but this is basically what we are looking for when transferring a mob or object from one containing element to another.</p>
    <p>Observation is much easier than this. It can even be done asynchronously in cases where the answer is not required to accomplish another action. Synchronous situations will be things like when a mob enters a location and get its first view of the current contents. The mob asks another element to tell it something, waits for the answer, and then carries on with whatever it was up to. Asychronous situations are things like a player asking to refresh the location view, check inventory, peek at another mob's inventory, etc. The controller sends the request to the mob, and the mob sends a request for information, and whenever the mob receives an asynch information message it gets passed to the controller. Because this asynch communication doesn't require an initiating request the location can broadcast observations to all mobs when another mob enters, performs a visible action, or says something out loud.</p>
    <p>Getting and putting objects is similar to movement, but in this case instead of mobs changing from one location's inventory to another in a transaction managed by a way, an object is changing from one entity's inventory to another. When something is picked up, it should be removed from the location's inventory. When it is dropped it should be added to the location and removed from the mob. If it is handed to another mob it should be removed from the giver and added to the recipient. Not too hard a task, but one which once again must be structured as a synchronous transaction to prevent weird cases like adding random objects to an inventory based on asynchronous receipt of old messages, or dropping objects from inventory even though the receiving process doesn't exist. Making this synchronous also means that two mobs can't get the same thing at once and accidentally dupe it in the process, because the location will block on the pickup message, remove the object, and then handle the other mob's get action message. We do have a complication, though: two mobs passing an object will introduce the symmetric synchronous protocol deadlock problem again, and so we should create an intermediate process to handle the transaction the same way the ways do for locations. This is a process we can just spawn and kill once its work is done. We'll call these "hands" for lack of a better term. Drat! Another "unseen" module!</p>
    <p>Chat would be hard to implement if it were synchronous. But it won't be. Ha ha! We'll just be simple for now and fire chat messages off into space and assume everything works out. With a bazillion chat messages flying at once I don't really care if one gets lost, and it won't crash the game system. Anyway, the Erlang runtime guarantees delivery of a message so long as its target is alive, and that is really all we care about. This promise is actually quite amazing. It makes creating things like chat systems very simple. But the chat system is not critical to the game world, just the users. We can defer the global chat system for now, but make sure we do implement an asynchronous method for "saying" things in a location and having other mobs "hear" it.</p>
    <h3 id="hands">Hands</h3>
    <p>Hands are to mobs as ways are to locations. They provide a way to make symmetric synchronous messages avoid deadlock and offload the complexity of transaction handling. Hands will probably be used a lot less frequently than ways, so we can spawn them and let them die when their job is done without any issues. Because hands will probably be fairly similar to ways, at least in some respects, we will avoid thinking about them exhaustively here, commit to implementing ways first, and then work on hands once we've worked our way around the details of transactional transfer (or full-blown two-phase commit) in ways. Because there will be quite a bit of inventory transferral in our MUD its a good idea to be alert to opportunities to abstract the procedure of two-phase commit or transactional transfer so we can invoke it where needed instead of rewriting the same basic thing (possibly wrong) over and over.</p>
    <h3 id="controllers">Mob Controllers</h3>
    <p>Mob controllers separate a mob's volition from its corporeal existence. Mobs should be written to require exactly one controller be active at a time (there can only be one!) in the same way that real animals are only under control of one consciousness at a time. When a mob is spawned it will initially lack a controller and therefore spawn one. What sort of controller to spawn can be a part of the mob's definition, even subject to a randomizing factor (as in 70% of all cats are nuts, 30% docile).</p>
    <p>There are a lot of natural benefits to this sort of structure. When we want to let a player take over it can spawn a controller to replace the existing one, and if the player logs off the mob can respawn its default controller. If a player's ISP flakes out or he switches from laptop to phone to play he can just log in again on a new device and that will cause a new controller to spawn which will replace the previous one. It makes no difference whether the previous controller was an AI or a player controller, the mob doesn't care and so neither should we as designers. This simple rule means we don't have to write any special "takeover" procedure for mobs.</p>
    <p>Obviously mobs and their controllers will pass quite a few messages, probably many more than we would care to detail here. For now what we want to do is just cut the unknown complexity down a bit by thinking about what categories of messages will be passed, from which direction they will initiate, and whether they should be synchronous or asynchronous.</p>
    <p>In Erlang its usually a good idea to default to asynchronous messages as much as possible. Its the same reason we love fire-and-forget weapons like the javelin: they are simple to the operator. We should try to write everything asynchronously first, and only when that turns out to be impractical switch to synchronous messaging (excluding cases where we know in advance that a transaction is called for). This is the way we will approach controller/mob messaging at first. We know we will have commands (controller→mob), results (mob→controller), incoming info (mob→controller), incoming chat (mob→controller), and outgoing chat (controller→mob). we also know that mobs and controllers should be linked, so if one dies the other does a well (which, if we stick to the location-wide linkage discussed above, should also kill the location and everything in it). So far I don't see anything that should obviously be synchronous, except perhaps commands and responses. But with two processes linked I still don't see the necessity of synchronous messaging; if the mob takes a while to complete an action the controller shouldn't be blocked (that would limit our options for external mode or minigame possibilities which don't involve the mob directly).</p>
    <p>So we'll go with asynchronous messaging for everything to begin with, and examine the protocols that result later on to determine whether this remains feasible. Since locations and everything in them explode when anything goes wrong we should fairly quickly be able to detect the presence of corner cases and bugs in the future.</p>
    <h3 id="mobman">Mob Manager</h3>
    <p>Oh look, another manager. In the same way the object manager receives information about what objects should exist and spawns whatever is necessary, the mob manager receives similar information and spawns whatever mobs are necessary. As discussed above, once a mob is spawned it will make sure it has a controller, so we don't need to worry about that sort of thing here. The primary job of the mob manager is respawning crashed mobs and keeping mob populations to appropriate levels.</p>
    <p>That last bit about maintaining mob populations is the same issue we encountered with the object manager, where it must decide when to load objects based on what objects have been destroyed in the course of world events. The mob manager must similarly spawn mobs to replace ones that have died in the course of world events, but only to a level that is reasonable. We can do this by keeping a total count registry of mob/type, or by making each non-player mob instance have its own place in a registry (so you get exactly one-for-one replacement, maybe even contiguous AI history — an interesting idea), or whatever. I'm inclinded to try the "total count" version first, but based on whatever data storage representation makes the most sense early on I might switch to the contiguous registry idea. There isn't really an Erlangy way of handling this sort of issue, so we will have to explore on our own to determine what makes the most sense.</p>
    <h1 id="scaffolding">Scaffolding</h1>
    <h2 id="telnet">Telnet interface</h2>
    <p>MUDs traditionally work over telnet and do not require any special client-side software. We will follow this tradition in ErlMUD, at least for a while. It is common for clients to be written that understand a particular MUD or MUD family's textual structure, commands, alias system and map representation, and simply use the telnet protocol to connect on behalf of the user. Using TCP sockets is easy enough in Erlang compared to C that its tempting to break with tradition and just write a new TCP protocol and a client and server of our own on both ends. We're not going to do that, at least not yet. The reason is that telnet is easy, and easy is a good place to start when writing a new project with a design that is untried. I'm pretty sure I can get the internals of the main MUD elements to work, at least in a hackish way, without too much trouble. I'm also pretty sure that if I mess with it a bit I can host write a telnet server (should be a lot easier than doing it in C in the past). This is already a significant amount of work to do, and both are things I've never tried before. I don't want to add a new network protocol, a whole new application (the client software), an installer or package(s) for that client, and a way to get the client to users to the list of things on my plate just now. We're not even into the code yet. If any feature isn't absolutely essential we should consider if its something we might want to write it down, and then forget about it (hopefully forever).</p>
    <p>Telnet is a pretty simply protocol, but, as indicated above, may not be the only way we will connect to the MUD. Consider that even without client software we might want to be able to connect over a secure channel instead of Telnet, since Telnet is all plain text, including passwords (oh no!). So designing the system so that the telnet connection is a component that the main service manages, and not a bunch of networking code written directly into the main system loop, is a good idea. That gives us options, and even if we never exercise the option to connect through some other method (consider how nice it would be to connect directly from an Erlang shell on another node...), it will force us to do the right thing early on and separate the detail of how we connect to the network from the fact that we connect to the network.</p>
    <h4 id="chat">Chat system</h4>
    <p>Chat is one of those things that isn't arbitrated by locations, globally accessible, and not an option. There are a few things we have to think about when implementing a chat system. For one thing, each location is sort of its own little chat server, since all verbal and emote activity is visible to other occupants. We might want to implement something like a "shout" feature, where any really loud action (like an actual shout) can be heard to all occupants of locations within a zone, or maybe heard X-locations away. We might also want to mimic a fun feature of WoTMUD, where players of two different species can only understand their own kind but still share basically the same channels.</p>
    <p>Channels? Hrmmm. That's a lot like locations again. So the real question is, how do we prevent ourselves from duplicating a ton of code? Another issue is whether a mob joins a channel, a controller joins a channel or a player's connection handler farther up the stack joins the channel (and is the player's connection the same as the controller?). Previously we had established that mobs require controllers and that separating controlling logic/interfaces and the mobs themselves is probably a good idea. Now we come to the question of "what part of a mob has ears and eyes?". I think it makes the most sense to give the mobs themselves the sensory organs, route chat messages along to the controller the same way other observations are, and let the controllers handle or disregard messages as needed. Then I can avoid writing any special case code into "chat listeners".</p>
    <p>What about private messages, like "whisper" or "tell" features? Its easy enough to implement a "tell" that makes one mob send a chat message directly to another mob, bypassing anything else. We can even say that each mob maintains its own "ignore" list and avoid having to write a central nanny message arbitration function. But this issue with ignores, private messages, channels, listening for shouts, emotes, verbals, etc. is already demonstrating that chat is actually not such a simple part of the game, simply because targetting, routing, listening and filtering are all issues we start having to suddenly deal with.</p>
    <p>Actually, I don't want to put this into the mob's core logic. I really want to just have a single message tag, like <code>{chat, From, Message}</code> and have <code>Message</code> contain the message itself and a meta message that we can perform filter, routing, etc. logic on. And I don't want to write that logic into the actual mob processes themselves, because I'm pretty sure the metabolism and combat system is going to fill quite enough lines of code as it is. So we should write a second, assistance module for mobs that behaves like their sensory organ. Chats can either target that directly, or target the mob and the mob pass its message into it asynchronously (this is the kind of process I would link, so its logically a part of the mob, and if either crashes the whole mob crashes), and the sensory process can take over from there.</p>
    <p>We need to write a system of channels which can be created, joined, left, and moderated. This will probably look a bit like the way locations are implemented, but without all the extra logic of physical arbitration, travel, or anything else hard. We don't need a map, either, but we may want to define some boundary conditions for chat channels, like default instantiation of factional or race-based chat rooms or something of that sort. To begin with, though, we should probably aim low and write a single global chat channel, then once we understand that, add another, and then add an in-game way to identify who should automatically belong to faction-type channels, and make a way for players to create channels in-game as well.</p>
    <p>So that's the plan for now: first get a simple, global broadcast type chat working, and diversify from there based on whatever features we decide to implement later on. At first, anyway, with zero or very few players we won't really need to do much with channels, so we can keep in mind that we want to implement channels later on, but skip doing anything with that idea for now.</p>
    <h4 id="player">Player registry</h4>
    <p>People have to have some way of identifying themselves to the game server so that it can locate their character. Or not. We might want to design a game world where every time you log in you randomly inhabit a pre-existing mob and engage in whatever is going on nearby on your own. This is actually a pretty interesting idea, so I'll write it down, but for now I'm going to do the old-fashioned (and not very secure) username/password way of doing things.</p>
    <p>But do players have accounts and characters, or is every character an account? Mobs will certainly have some concept of points or level status or something, but is this different than an account system or is the character system itself all there is to the account system? I like the free feeling old MUDs give by making characters painless to create and totally independent of one another with no account system above this. On the other hand, players today are pretty used to the World of Warcraft account model where one account owns several characters. The problem there, of course, is that if your account gets compromised all your characters are compromised at once. Its a player-side version of putting all one's eggs in one basket, which is good to avoid. Perhaps a good middleground is possible, where we create an account system, where each account owns only one character, but make it possible to add additional characters later on, but just not implement the command functionality for that yet.That means we need player accounts, and they need to track what mobs they own.</p>
    <p>So that's two things to implement: a storage system for persistent character data (whatever the system remembers of you when you "rent" or logout), and an account storage system for tracking account/character relationships.</p>
    <h4 id="erlmud_start">erlmud:start/0</h4>
    <p>Any system needs a way to get started. Some folks write this module in as much detail as they can first, and then work from there down to the details. Some folks work on the tiny components first, assembling their code from little blocks as they go. I mostly do the top-down part, but don't spend much time on detail at the highest level. Instead I usually write a <code>somapp:start/0</code> function that barely suffices to spawn a unique process, and then revise from there as I go. I've decided that this prevents me wasting time on too much detail that I don't have any hope of understanding just yet. It also allows me to be lazy at the high level and geek out at whatever level of the problem interests me first, so long as I am diligent enough to fill in the execution path between <code>start</code> and whatever I'm working on.</p>
    <p>This is one place that it can be good to start trying to iron out the verbiage of your project very early on. Write your initialization bits in a way that deals with your major system components at the level of abstraction you want the rest of the world to. Starting this early on forces pushing details to other modules, particularly in the case of whatever data models are used to start up the system. The last thing we want is for whoever configures the system and might actually deal with some top-level component to have to know that object state is represented as a tuple of form X underneath. Yuk.</p>
    <p>I'm going to leave this one wide open for now, and only implement a direct code path that spins up the application and phrase things in the initialization procedure in a way I think is natural. It will probably be wrong, or at least not look much like whatever the production version of this module will look like, but that's OK for now.</p>
    <h1 id="summary">Summary</h1>
    <p>Whew! That's quite a bit of stuff. Its enough that I think we need a quick summary of the bits above, just so we don't get overwhelmed by all the detail and rambling thoughts that passed above. The system is still quite small, after all.</p>
    <p>Game elements:</p>
    <ul>
      <li>Locations</li>
      <ul>
        <li>Ways</li>
        <li>Location Manager</li>
      </ul>
      <li>Objects</li>
      <ul>
        <li>Object Attributes</li>
        <li>Object Messaging Protocol</li>
        <li>Object Manager</li>
      </ul>
      <li>Mobs</li>
      <ul>
        <li>Mob Attributes</li>
        <li>Mob Messaging Protocol</li>
        <li>Mob Controllers</li>
        <li>Mob Manager</li>
      </ul>
    </ul>
    <p>System elements:</p>
    <ul>
      <li>Telnet</li>
      <li>Chat</li>
      <li>Player Registry</li>
      <li><code>erlmud:start/0</code></li>
    </ul>
    <p>At this point we have a firm enough idea what the primary game elements are supposed to do that we can begin sketching them out in pictures or very simple (psuedo)code. In the next section we'll start implementing very simple versions of each of these pieces in an order I think is reasonable, and add code a bit at a time until we have a very basic world simulation engine in place.</p>
    <p>It might seem strange to leave the question of whether potentially tens of thousands of object processes sitting around in memory, maybe noisily messaging each other all the time will be a problem later on or not. In an OOP type system this might be rather hard to fix later on if not designed out of the system right now. Gobs of dependent calls sprinkled throughout the code might have to be fixed. But I've found in my experiences with Erlang that its usually best to blithely assume that the "everything is a process" concept will work out fine (unless there is some really obvious reason it won't), and that fixing performance issues only makes sense to worry with once some hard performance data from the actual development system we're working on is available. It is relatively easy to switch message routes around and replace the representation of components within even a relatively complex system. A big part of this has to do with the way we will encapsulate the data we are working with, and Erlang's refusal to let us share anything between processes helps prevent us from coding ourselves into a troublesome corner in this regard.</p>
  </div>
  <div id="footer">
    <div id="nav"><a href="000-001_introduction.html">&lt; Previous</a></div>
    <div id="nav"><a href="index.html">Home</a></div>
    <div id="nav"><a href="001-001_concept.html">Next &gt;</a></div>
  </div>
</body>
</html>
