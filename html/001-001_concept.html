<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" />
  <title>ErlMUD Notes: Concept | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="concepts">ErlMUD Concepts</h1>
    <p>ErlMUD is a simple Multi-User Dungeon that runs over telnet, inspired by joyful memories of playing dialup BBS door games and MUDs before the advent of residential internet. It is written in a way that takes advantage of Erlang's concurrent, strict message-passing model and the few promises provided by the Erlang runtime.</p>
    <p>This commentary follows the development process of ErlMUD as it undergoes changes, feature additions and design evolutions. The code is written several times iteratively, gradually adding features and — most importantly for the purpose of this project — evolving in terms of code style from a primitive system of limited functionality to a full-blown production system that would (hopefully) not drive future maintainers mad.</p>
    <p>This chapter begins by discussing some aspects of design that are common to any project, details the primary elements necessary to create a MUD game world, and then discusses secondary elements and other "unseen" aspects of the project which are necessary for implementation. The purpose is not to hash out every detail in prose, but rather to think about the problem in a general way and discover some of the unobvious issues that will have to be dealt with in order to implement the game system. The goal of the implementation is to elevate the primary game elements to the level of abstraction that we want to deal with so we can dispense with the details under normal conditions.</p>
    <h2 id="elements">Elements</h2>
    <p>In any project there are two categories of elements. There are those elements which obviously must be a part of the design, and those that require discovery on the part of the developer.</p>
    <p>The obvious parts are clear to us either because they represent a resource we know is required beforehand or because interacting with these elements is the purpose of the program. At the outset of the project this is what is seen.</p>
    <p>There are other elements, however, which are not so obvious and must be discovered through exploration and experimentation. The exploration part involves working through the problem space, discovering exactly what it means to handle the problem. The experimentation part consists of trying different methods to handle the problem and evaluating the resulting system by some balance of criteria to determine the "right" design (or, more often, the "least wrong" design). As the problem is explored and little experiments progress developers will come to the inevitable realization that handling the problem is not as easy as it initially appeared, that too much understanding of the problem was assumed at the beginning, and that previously unconceived elements are necessary to deal with the problem. At the outset of the project this is what is not seen.</p>
    <p>The "seen" bits represent a basic description of the problem and the "unseen" bits represent the implementation. This is analogous to the difference between reading the definition of a square root and coming up with an algorithm to derive them. Erlang is a very high level language in many respects, but it is not so advanced that we can simply plug in a mic and demand "Make me a system that does X!" and get what we want.</p>
    <p>When writing software for ourselves we usually know what features we want and can quickly enumerate the "seen" bits. It is our lack of understanding of the unseen bits that bites us in the ass later. (The "unseen" ass-bitings come in a striking variety of forms!) When writing software for customers, however, the most frequent problem is that the customers are themselves not able to "see" the parts that should be initially "seeable". (Some customer engagements can be quite a rodeo...) The solution most programmers have adopted is to jump ship just after initial release and leave users and future maintainers to discover the need for Kevlar underpants on their own.</p>
    <p>The fact that there are obvious and unobvious elements of the system is part of why projects must evolve as they move forward. Sometimes an "evolution" means simply tweaking an interface or adding some method of type checking to catch latent mistakes early, sometimes it means radically changing a data schema, and sometimes it means a general re-write because we discover that a current approach is not working (or that it works, but is too costly to pursue). We will see a broad range of evolutions as ErlMUD grows.</p>
    <h3 id="seen">That which is seen</h3>
    <p>"MUD" stands for "Multi-User Dungeon". MUDs are multiplayer adventure games, usually accessible via telnet or ssh, and generally provide a line-based text interface. Locations in MUDs are defined as "rooms" or "sectors" which are often grouped into "zones" which share some common behavior. Entities in MUDs are animate "mobiles" (or "mobs") and inanimate "objects". A player character is represented as a mob which is under a user's direct control. An arbitrary range of movement methods between locations is defined, often unique to each game system, and an arbitrary range of interactions is defined between animate→animate and animate→inanimate entities.</p>
    <p>Combat is often a strong component of a game world, but in some MUDs chat, emotive actions or roleplay is the focus. In any MUD, whether combat or roleplay based, there is a strong user expectation of community involvement. The primary motivation of most MUD players is themed interaction with an online community, not mere interaction with the game world itself. Many MUDs run for decades with the same general player base, and are expected to be generally stable for as long. Most MUD systems are usable as backends for either combat/adventure or chat/social servers. In a certain sense, MUDs can be considered super-advanced chat servers, though it seems that most MUD authors do not think of them in this way.</p>
    <p>From the description above, and from taking some time out to play a MUD or two (seriously, try one), we can determine that the primary game elements we need to deal with are:</p>
    <ul>
      <li>locations</li>
      <li>objects</li>
      <li>mobs</li>
    </ul>
    <p>While the other system elements that are obviously necessary are:</p>
    <ul>
	  <li>telnet interface</li>
      <li>chat system</li>
      <li>player registry</li>
    </ul>
    <p>So far, this is what we can see. Let's take a closer look at each of these and think through what supporting elements we might need to implement.</p>
    <h4 id="locations">Locations</h4>
    <p>A location is a self-contained place within the game world where actions which immediately affect mobs take place. Our guildeline is that if a mob performs a physical, verbal, or emotive (or "emote") action it should only be visible to or have a direct effect on another mob in the same location. This should be distinct from the chat system and probably most other actions that can occur at a distance.</p>
    <p>There are two basic ways to implement locations. They could be entries in a universal registry where mobs, objects and associations among locations can be tracked in tables that indicate their relationship to the location. Alternatively, they could be processes which do their own entity tracking and are directly responsible for arbitration of physical actions.</p>
    <p>If we use a global-registry then we have the problem that nearly every action in the world depends on this registry. If this were done in a single process it would be a pretty busy one, but guaranteeing consistency would be relatively simple. If it were done in a worker pool the load could be distributed, but consistency would be much more difficult to guarantee and the registry store itself would still be a bottleneck. Either way, we would be putting all our eggs in one basket. If this registry were to die so would the MUD.</p>
    <p>Consider how complex such a monster registry would become over time. Once we give too much responsibility to a single piece of code the tendency is to increase the number of responsibilities it handles over time. This is against every good practice we know as engineers, but under the pressures of real life, business, and expectant users this is what tends to happen. It is quicker to hack "just one more" feature into an already overloaded system than to sort out the tangle of responsibilities and then implement an additional feature orthogonally. One Registry To Rule Them All is actually a pretty normal design in an OOP or imperative style MUD, but I don't think its a good fit for Erlang.</p>
    <p>The other way, where each location is a process, seems more sensible to me. If locations are processes then we avoid creating any bottlenecks and crashes can occur at a small enough scale that we can probably recover from them without affecting. This design is also easier for me to reason about because it is closer to being a genuine simulation of a world. This is the way we will try first.</p>
    <p>Each location will need to keep track of whatever mobs, objects and connections to other locations are present. If a mob, object or adjacent location were to crash the location should carry on. The location's job is to arbitrate activity within the location (someone closes a door, drops an item, etc.), answer queries about its current state (who/what is here, what exits are available, etc.), and broadcast location-wide notifications (a mob enters the room, says something out-loud, etc.). This is a fairly simple list of responsibilities that we can probably model in a single process without getting confused.</p>
    <p>There is a lingering problem, though. Locations will need to keep track of the status of adjacent locations and arbitrate the movement of mobs between themselves and those other places. This means two identical processes will have to communicate, and this communication will need to be synchronous. That means we need to watch out for deadlocks. (Oh noes!)</p>
    <p>My way of avoiding this kind of deadlock is usually to create another type of process that takes care of the synchronous communication on behalf of one of the two processes. This lets me design a protocol that at least isn't guaranteed to have a deadlock built in (whether our protocol actually avoids deadlocks is a different issue, but this way at least we're not guaranteed to have one).</p>
    <p>In this case I think it makes sense to create a "way" process that represents a one-way path between two locations. This lets us create interesting maps without adding new logic the locations themselves (one-way portals, for example), and it also gives us an easy method for implementing other game elements like shuttable/lockable doors, hidden paths, temporary portals, fuel-operated warp gateways, or whatever. Separating the idea of a "way" from a "location" gives us a lot of advantages both in terms of modeling the game world and in preventing kinks from emerging in our messaging protocol.</p>
    <p>So there we have it, we've identified our first "unseen" element: ways. We'll worry about the details of ways a little later on, but its good that we have identified that locations do not stand alone within the game system.</p>
    <p>Something we glossed over up to now is how to instantiate the locations. Where do they come from? Since we will probably have a map defined in permanent storage that gets pulled during startup/reload a traditional system of supervisors that manage workers will be a good fit. We can assume, then, that we'll probably need at least a "location manager" process that spawns locations and restarts them if they die untimely deaths. There might be other things we want this process to do, like alter the map dynamically, but we don't have to worry with that for now. At this point it is sufficient to say that our second "unseen" element is a location manager that supervises the locations and that the locations are workers at the bottom of the supervision tree.</p>
    <h4 id="objects">Objects</h4>
    <p>Any inanimate thing in the world that can be manipulated is an object: weapons, armor, consumables, light sources, money, clothing, food, containers, etc. Different types of objects may have special behaviors, like food that spoils over time, or a weapon that wears out or a piece of clothing that can only be worn on the head. Objects need a way of being created, destroyed, picked up, placed in containers, act as containers, used as ingredients or food, and any other in-game action we might come up with.</p>
    <p>This tells us that the design of objects is not as easy as we may have initially thought, and may not even fit within a single definition. Perhaps a food object should be defined differently than a weapon object, but adhere to a similar generic interface of "object". Maybe objects should be a central digest instead of being processes. We're not sure at this point, but it is certain that being able to interact with game-world objects in a natural way is a system requirement.</p>
    <p>I've got three basic ways in mind about how to implement objects. One is to make a central object registry that keeps track of all objects across the game world. Another is to do things the C-style MUD way and have a library of object type definitions we can copy into structs based on the type that is needed, and mobs, locations and container objects could pass pointers to those structs around to represent associations that they track themselves. And yet another way is to make every object a process of its own, the way we do with locations.</p>
    <p>The central registry style suffers from the same problems a central location registry would, so that's out. If we thought a location registry would become a bottleneck and complex to implement, imagine how busy an object registry would be! There is a lot less travel and position checking in a MUD than object-influenced activity (every combat action might take weapon and all clothing/armor stats and total carried weight into account, for example), not to mention the variety of behaviors that would have to be coded into the object registry to implement diverse things like ingredients, food, equipment, etc. No thanks.</p>
    <p>Passing pointers around would be nice, but this isn't the way Erlang works: we can't share memory. The entire tuple representing the object would have to be passed between locations, mobs, and other objects as messages, and each of these process types would have to know how to interact with them. (For the curious: Screwing up the procedure of passing pointers or creating/destroying structs/objects to represent item passing is the source of many an item dupe bug.) If the shape of the object data ever changed, that would cause a lot of surgery throughout several other modules. Record syntax could help us there a bit, but then we'd have to share record definitions across source files, and that gets wonky. A better way would be to wrap the object data behind a functional interface, and this might be a workable solution. But where would we put the influences of objects themselves? Let's say we want to implement food that decays over time. We will need to write some logic in location code that updates the state of the food it contains to effect the decay, and we will also need to write very similar logic into mobs and container objects to make sure the same things happen there as well. And where is the code for container objects now? This is actually not sounding like such a good idea. Its simple to think about passing a tuple that represents an object in the game world, but not so simple as soon as we want those objects to exhibit some sort of behavior of their own.</p>
    <p>That leaves us with designing objects as their own processes. This lets us do all sorts of cool stuff, because we can code "object logic" directly into them and give them their own processing loops, timers, state, etc. But what about the different categories of objects? How do we make food, weapons and containers fit into the same definition? We might not be able to. I'm not so sure that objects will fit into a single definition, we may actually need several to keep our code understandable. But that's OK, because there are no constraints on process type with regard to message passing.</p>
    <p>What we really need is a messaging protocol for objects. That way objects of a certain type can identify themselves if necessary, have their own behaviors with regard to messages received and sent, and all look basically the same from the outside despite their internal differences. (Sound a bit like "duck typing"?) An oven could be a finite state machine, a container a service process, and food could be some new "food behavior" we have yet to invent. The point of defining objects as a protocol and not some specific process type is that it permits us to defer the details of any particular object type until later. We can play with this protocol early on by creating some generic object type at the outset which will grow to represent our basic object message protocol, and keep in mind that implementing special object types will require new modules that adhere to the basic protocol. Of course, to design a protocol we have to determine what to talk about first, and that means we have to establish some basic attributes common to all objects.</p>
    <p>Here we have two unseen elements: generic object attributes and the object messaging protocol. We knew at the beginning that we wanted to have objects in the game, but until now it wasn't clear that "objects" would have to be a category of process definitions which adhere to a messaging protocol as opposed to a single type of process or data structure.</p>
    <p>It might seem strange to leave the question of whether potentially tens of thousands of object processes sitting around in memory, maybe noisily messaging each other all the time will be a problem later on or not. In an OOP type system this might be rather hard to fix later on if not designed out of the system right now. Gobs of dependent calls sprinkled throughout the code might have to be fixed. But I've found in my experiences with Erlang that its usually best to blithely assume that the "everything is a process" concept will work out fine (unless there is some really obvious reason it won't), and that fixing performance issues only makes sense to worry with once some hard performance data from the actual development system we're working on is available. It is relatively easy to switch message routes around and replace the representation of components within even a relatively complex system. A big part of this has to do with the way we will encapsulate the data we are working with, and Erlang's refusal to let us share anything between processes helps prevent us from coding ourselves into a troublesome corner in this regard.</p>
    <h4 id="mobs">Mobs</h4>
    <p>Finally. the focus of the game. Mobs are what do the verby things in MUDs. They are the world creatures, the NPCs, the player avatars, the predators and the prey. Every beast, player, NPC, demon, perpetually kidnapped princess or whatever else we decide to include in the game world that is alive falls into this category. Anything that is attackable, killable, aggressive, prone to flee, talk-to-able, bound by in-game laws, factionalizable, grouppable, emotionally conscious, ridable or ownable as a pet, passengerable, or definable as friend or foe is a mob. Without them the MUD would be a pretty boring place.</p>
    <p>Knowing that all the above types of actions and attributes center around mobs indicates that while a general definition of mob may suffice at the outset, mobs will likely also require a message protocol definition that lets us write a variety of mob types that do different things but interact with the system in a similar way. This isn't so different from our discussion of objects, above, really. The main difference is that while it wasn't so obvious at first that objects should be processes, it was always clear that mobs would be. In both cases we find ourselves settling on an initial, generic implementation of each so we can explore the message protocol in more detail, knowing that we will almost definitely be writing a few unique modules that adhere to that protocol later on.</p>
    <p>The similarities between objects and mobs only goes so far. They don't do anything so they don't have players or AI controlling them. Mobs do things. How do we make those actions happen? What determines what action happens when? If we put a dog mob somewhere, will he ever leave? Will he chase rabbits on his own? Where does that go? Do we re-write a new module every time we come up with a new mob type (and then have to change all thousand of them if we ever decide to change the mob messaging protocol? Ouch!)? Something is clearly missing here. We need a controller.</p>
    <p>While it would certainly be possible to write the AI elements directly into a mob, that would pose some problems. For one thing, every mob would need different AI or else the world will be remarkably inflexible. Having an evil miniboss and the town blacksmith share the same AI would pose a problem. It also limits our options: what if we want to create a game world where all the mobs already pre-exist, and players just take control of mobs in place and play that way? Its not traditional, but its an exciting idea. What if game staff (usually called "immortals" or "imms") want to enhance roleplay possibilities temporarily by taking control of a village NPC and providing some live interaction? We can't do those things very easily if the controlling code and the mob code are intermixed. Well, to be specific, it might be possible to implement that sort of a system exactly once and never change it again, but smooth evolution of a codebase is one of the most important things we have to think about as developers, and its no good to tie a big Gordian Knot of concerns right from the start (though this seems to be the norm in many projects).</p>
    <p>To perform actions mobs will have to know where to send messages that represent or initiate actions, be able to somehow observe their situation in a reliable way, maintain an inventory, know what state they are in (awake, sleeping, in combat), have some mechanism of determining the effects of received offensive and defensive actions balanced against ongoing effects that influence the impact of such received actions. This implies that mobs must have some mechanism for being spawned, being hurt, being healed, dying, and being respawned.</p>
    <p>But that is just life and death. The whole range of things that occurs between a mob's spawning and its death is what we are really interested in. How do mobs communicate? Not in the sense that their processes send messages to other processes, but within the semantics of the game world. Can a player's avatar talk to another player's avatar? How does this happen? Obviously mobs other than players are going to move around. Where are the decisions for the NPCs made? Within the mob model, in some global process that controls everything players aren't controlling, or by some other process? Critically for us as programmers, we have to find some design that makes the interface between mobs in general and other elements of the game world as perfect an abstraction as possible, so that the design of locations and objects will not have to take into account whether the mob processing sending it a message is an NPC, a player, or some other mobile entity. This is not terribly hard once we realize how important this form of abstraction is, but if we hadn't thought things through this far and simply sat down to write out the entire game system in one huge module we would quickly find ourselves in trouble.</p>
    <p>This idea that mobs must be abstracted from other elements of the game world, and that mobs must have some mechanism for making decisions brings up an interesting aspect of Erlang design. Let's consider the difference between an NPC and a player character. A player character is connected to a player across the network somehow and this player is making decisions in his mind and sending commands back to the mobs which it is acting upon. The NPC is somehow making decisions on its own. We can either design two completely different mob modules, one for NPCs and one for PCs, where the NPC contains some AI mechanism and the PC contains some network connection handling code. This requires we develop a strict protocol or interface definition among the game elements that are considered mobs, and adhere to it within the design of both NPCs and PCs. Locations and objects would have no way of knowing whether they are communicating with an NPC or a PC so long as the communication protocol perfectly abstracted the concept of mob. The other way of doing things is to design a generic mob concept which knows how to interact with the world and to accept commands (like the PC mob above, but without the network code), and then develop a "controller" sort of process which might be a "PC controller" type that knows how to talk to players and an "AI controller" type that knows how to make NPC decisions.</p>
    <p>Whatever we decide, it will have an impact on how development will go and how easy it is to change things around in the future. If we create two different mob types, then the protocol that both mob types must adhere to spans every point of interaction with every other game element. This is burdensome if we want to implement mounts, for example, because every place that relates to mount implementation will have to change across both the NPC and the PC code. in most code this is handled by slowly crippling the functionality of NPCs in favor of spending development effort on adding features to PCs. If, on the other hand, we develop a general mob process and then place a controller behind it, we can much more easily develop a flexible system. With such a design it would even be trivial to permit players to take over control of mobs in progress, or pass control of their characters to AI controllers in the middle of play instead of renting a room at an inn or simply idling out in space. This sort of design is not just better because it will ease our burden as programmers, but its better because it enhances the options for how the system can be made to behave.</p>
    <p>Controllers and mobs will be discussed in more detail later on</p>
    <h4 id="telnet">Telnet interface</h4>
    <p>Gotta talk to the thing somehow...</p>
    <h4 id="chat">Chat system</h4>
    <p>Gotta talk to the peepol.</p>
    <h4 id="player">Player registry</h4>
    <p>Hate the game.</p>
    <h3 id="unseen">That which is unseen</h3>
    <p>In thinking through the three main elements of the MUD some indications that a three-module codebase was going to be insufficient. When discussing locations we mentioned that locations have quite a few more responsibilities than their imperatively implemented counterparts do, and while we're sure that locations will be required to handle some message broadcasting (notifications to everyone in the location), directory lookups (who or what is in the location), and respond to basic queries (give the room description, name, etc.), we left open the non-trivial question of how locations are to  be interconnected. When discussing objects and mobs a list of attribute descriptions was given for mobs, but not for objects. What objects can "do" (if they can do anything) and what mobs can do, and where some crossover may exist was never addressed. In particular, we never developed a concept for how a world object that is not a mob might behave. Ultimately, we have no idea about how to implement time-decaying foods, traps, or anything else of that nature. The trap case is discussed below as an example. The discussion about mobs also touched on a very important subject: the mob controllers. These issues and complications arising from them, will be discussed in more detail below.</p>
    <h4 id="ways">Ways</h4>
    <p> In particular, the issue of how locations know its safe to permit a mob to depart to a certain adjacent location, how it knows the adjacent location's process is up, and how to handle the concept of open/closed/locked ways or doors to other locations has been left unaddressed, but that little sense programmers often have that something is not quite as simple as it seems on the surface is telling me that this area of functionality is both complex enough that it requires its own logic and orthogonal to the basic duties of a location to justify being placed in a separate module.</p>
    <h4 id="traps">Traps</h4>
    <p>At the beginning of the <a href="./001-001_concept.html#mobs">Mobs</a> section above I listed a series of descriptive qualities that mobs might have. Throwing out so many descriptions in terms of possible actions, adjectives and influences is useful to shape our thinking about the game world. For example, above I wrote "attack" but did not write "cast a spell". We should consider whether, for example, we want to include traps within the game world, and if so what sort of mechanism makes a trap work, and whether a trap is attacking, casting a spell, or acting on its victim by some entirely different mechanism. In short, we have to determine whether a trap is a "stationary mob", a mechanic governed by its hosting location, or some independent means that will require a new module that defines a trap as its own process. It is not particularly important at this stage whether we decide to include traps or not, but that we consider how to design a system in which traps are not impossibly difficult to implement.</p>
    <h4 id="object_attributes">Object Attributes</h4>
    <h4 id="object_protocol">Object Messaging Protocol</h4>
    <h4 id="mob_attributes">Mob Attributes</h4>
    <h4 id="mob_protocol">Mob Messaging Protocol</h4>
    <h4 id="controllers">Mob Controllers</h4>
    <h2 id="thoughts">Thoughts on implementation</h2>
    <p>At this point we have a firm enough idea about how the primary <em>game</em> elements could be sketched out in pseudo code (or crayon, for that matter), but the elements of the<em>system</em> have not yet been addressed at all. How does the system start? What do we call? How do we contact it? Where do locations, objects and mobs come from in the first place?</p>
  </div>
  <div id="footer">
    <div id="nav"><a href="000-001_introduction.html">&lt; Previous</a></div>
    <div id="nav"><a href="index.html">Home</a></div>
    <div id="nav"><a href="001-001_concept.html">Next &gt;</a></div>
  </div>
</body>
</html>
