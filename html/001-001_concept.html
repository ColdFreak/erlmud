<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" />
  <title>ErlMUD Notes: Concept | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="concepts">Concept</h1>
    <p>ErlMUD is a simple Multi-User Dungeon that runs over telnet, inspired by joyful memories of playing dialup BBS door games and MUDs before the advent of residential internet. It is written in a way that takes advantage of Erlang's concurrent, strict message-passing model and the few promises provided by the Erlang runtime.</p>
    <p>This commentary follows the development process of ErlMUD as it undergoes changes, feature additions and design evolutions. The code is written several times iteratively, gradually adding features and — most importantly for the purpose of this project — evolving in terms of code style from a primitive system of limited functionality to a full-blown production system that would (hopefully) not drive future maintainers mad.</p>
    <p>This chapter begins by discussing some aspects of design that are common to any project, details the primary elements necessary to create a MUD game world, and then discusses each element in turn and whatever secondary, "unseen" aspects become apparent as necessary for implementation. The purpose of this section is not to hash out every detail in prose, but rather to think about the problem in a general way and discover some of the unobvious issues that will have to be dealt with. The goal of the implementation is to elevate the primary game elements to the level of abstraction that we want so we can selectively dispense with the details.</p>
    <h1 id="elements">Elements</h1>
    <p>In any project there are two categories of elements. There are those elements which obviously must be a part of the design, and those that require discovery on the part of the developer.</p>
    <p>The obvious parts are clear to us either because they represent a resource we know is required beforehand or because interacting with these elements is the purpose of the program. At the outset of the project this is what is seen.</p>
    <p>There are other elements, however, which are not so obvious and must be discovered through exploration and experimentation. The exploration part involves working through the problem space, discovering exactly what it means to handle the problem. The experimentation part consists of trying different methods to handle the problem and evaluating the resulting system by some balance of criteria to determine the "right" design (or, more often, the "least wrong" design). As the problem is explored and little experiments progress developers will come to the inevitable realization that handling the problem is not as easy as it initially appeared, that too much understanding of the problem was assumed, and that previously unconceived elements are necessary. At the outset of the project this is what is not seen.</p>
    <p>The "seen" bits represent a basic description of the problem and the "unseen" bits represent their implementation. This is analogous to the difference between reading the definition of a square root and coming up with an algorithm to derive them. Erlang is a very high level language in many respects, but it is not so advanced that we can simply plug in a mic and demand "Make me a system that does X!" and get what we want.</p>
    <p>When writing software for ourselves we usually know what features we want and can quickly enumerate the "seen" bits; it is our lack of understanding of the unseen bits (or rather our naïve assumption that we do understand them) that bites us in the ass. When writing software for customers, however, the most frequent problem is that the customers are themselves not able to "see" the parts that should be initially "seeable".</p>
    <p>Projects must evolve as they move forward to cover the distance between between the early, intuitive understanding of the primary elements of a system and the unobvious bits necessary to implement them. Sometimes an "evolution" means tweaking an interface or adding some method of type checking to catch latent mistakes early, sometimes it means radically changing a data schema, and sometimes it means a general re-write because we discover that a current approach is not working (or that it works, but is too costly to pursue). A change of a few characters may represent a huge change of semantics, and a change of several hundred lines may represent a minor change in approach. We will see a broad range of evolutions as ErlMUD grows.</p>
    <h1 id="process">The process</h1>
    <p>How do we know what elements we will need? How do we discover the "unseen" bits? What part should we try to write first once we know what we're trying to do?</p>
    <p>There is an entire cottage industry built around trying to sell software development methodologies. They are all crap. I won't pretend to do any of that here. There is no One True Way to be found here; you'll always be learning how to improve your own methods. "Computer Science" is still not a science and it is only beginning to dawn on us that its not really about computers anyway.</p>
    <p>In the absence of a methodology to follow I'm going to be a bit of a traditionalist up front and commit to an early top-down approach to the problem of system design. This should work out reasonably well for two reasons: we have a huge headstart because we already know what a MUD is and there are many examples we can refer to in the wild; and the point of ErlMUD is to serve as a platform for demonstration of various styles of Erlang and OTP, not a place to obsess about demonstrating any particular development methodology to be the right one by contriving an example. Even if I have to go a bit further into "big design up front" mode than I normally would, there is a great value in being able to explain the system we want early on so that I can focus on the real purpose of this commentary.</p>
    <p>Once we do the big conceptual design bits in informal prose we'll skip around the scales of abstraction a bit, working some at the top and some at the bottom until we eventually mesh the two together into a working system. I don't know any other way to write an "actor model" or "concurrency oriented" system than to start writing some actors or concurrent processes. I think this is a fairly ordinary way of writing Erlang code, and I don't think it adheres to any official methodology. But that is unimportant.</p>
    <p>We will describe the problem in a general way then see if we can pick apart the conceptual pieces of it and segregate them into mechanical bits. The conceptual bits represent our intuitions about the system, the parts that are initially obvious which sit toward the top of the abstraction. The mechanical bits will constitute the next layer downward in the abstraction, the first big chunks of implementation.</p>
    <h2 id="problem">The Problem</h2>
    <p>"Write a MUD."</p>
    <p>Well, that was easy. It sounds simple when stated that way but it doesn't give us much guidance on how to go about it. What can we break that down into? If we take it at face value then its OK to hard-code world mechanics, a gameplay system, even game world and character data right into the source of the project. Yikes! That would be a nightmare. How do we avoid this?</p>
    <p>We can split almost any piece of software into three general pieces:
    <ul>
      <li>a platform or logical engine</li>
      <li>some operating rules</li>
      <li>instance data to operate on</li>
    </ul>
    <p>(Don't worry, this isn't a practical joke where we actually write a MUD in COBOL! Yay, divisions...)</p>
    <p>Consider a text editor: there is the editor program itself that manages the widow and user interface; there are contextual rules like settings, a plugin system, modes, and so on; and there is the text file data users are actually interested in. Now consider a browser: there is the browser itself that manages the window, socket connections, etc.; there are operating rules like plugins, scripting languages, rendering engines, download managers, email subsystems, ftp clients, and whatever other clutter; and then there are the web pages that users actually want to see.</p>
    <p>Not every piece of software is structured like this, but most of them are. Even rather small programs often work this way. Think about the programs included in <a href="http://www.gnu.org/software/coreutils/" title="http://www.gnu.org/software/coreutils/">GNU coreutils</a>, for example (cat, wc, ls, tail, etc.). Nearly all of them have a core routine (logical engine), a switch or script interpretation system (operating rules), and input data to operate on (instance data). Most of the time when you run across a program that doesn't follow this form you're looking at an early alpha, a convoluted codebase, or a throwaway program. MUDs run for years, sometimes decades, so we shouldn't commit to a design where these concerns are tightly coupled unless we really enjoy painful maintenance.</p>
    <p>A MUD system needs a world simulation platform, rules that define the gameplay, and world data. That means we need to identify what a MUD requires from a world simulator, create a way to define a gameplay system, and create a way to define game entities. Before we can break the system apart into these pieces, however, we need to define what a MUD is from a user's perspective.</p>
    <h3 id="definition">Define</h3>
    <p>"MUD" stands for "Multi-User Dungeon". MUDs are multiplayer adventure games, usually accessible via telnet or ssh, and generally provide a line-based text interface. Locations in MUDs are defined as "rooms" or "sectors" which are often grouped into "zones" which share some common behavior. Entities in MUDs are animate "mobiles" (or "mobs") and inanimate "objects". A player character is represented as a mob which is under a user's direct control. An arbitrary range of movement methods between locations is defined, often unique to each game system, and an arbitrary range of interactions is defined between animate→animate and animate→inanimate entities.</p>
    <p>Combat is often a strong component of a game world, but in some MUDs chat, emotive actions or roleplay is the focus. In any MUD, whether combat or roleplay based, there is a strong user expectation of community involvement. The primary motivation of most MUD players is themed interaction with an online community, not mere interaction with the game world itself. Many MUDs run for decades with the same general player base and are expected to be generally stable for as long. Most MUD systems are usable as backends for either combat/adventure or chat/social servers. In a certain sense MUDs can be thought of as super-advanced chat servers, though it seems that most MUD authors do not think of them in this way.</p>
    <h3 id="platform">The Platform: A World Simulator</h3>
    <p>In any conceivable world some mechanic must be provided to make travel between locations and interactions among elements in the same location possible. Locations must also have knowledge of their relationship to one another, and what objects and mobs are present at a given time. Also, there must be some way to define or generate a map that indicates location relationships.</p>
    <p>We'll probably find a few other things that the world engine should be responsible for, like maybe some concept of a universal timer, but in general anything that falls outside these areas are not responsibilities of the platform itself and fall to the level of gameplay or data issues. Consider for a moment what that means in terms of what the world simulator doesn't care about.</p>
    <p>The world doesn't care if mobs turn out to be ships in a space-trader, adventurers in a dungeon crawler, techno-dinosaurs questing for evolution juice, or whatever. The world doesn't care if objects are valuable, prone to decay over time, lockable containers, proximity traps, or anything else. The world doesn't care how players accrue points or experience or rank, or whether everything in the world is completely temporal. The world doesn't even care if the map is randomly generated each instance, is a static game map definition, or is some wacky bendy concept of higher-dimensional space in a Lewis Carrol sort of game world.</p>
    <p>Our platform is rather intimate with locations, but not as much with objects or locations. The world must provide a basic interface between locations and objects and locations and mobs, but shouldn't care what form the objects and mobs take internally. This is easy, since it means all we need is a messaging protocol that objects and mobs can use to interface with the world. The concept of chat is still up in the air, but aside from mobs talking to other mobs in the same location it is likely that any global chat system will probably also fall outside the scope of the world simulation as well.</p>
    <h3 id="operating_rules">Operating Rules: A Gameplay System</h3>
    <p>By separating the world from the gameplay we have avoided committing to any particular system of gameplay while writing the world bits. Any system of locations could serve as a platform for any system of entities (objects and mobs), so long as the parts conform to whatever message protocol we develop. In other words, we could design a grid world of locations and atop that implement shogi, chess or checkers.</p>
    <p>Moving a bit further with this ideas there are two important implications we need to think about. One is how the separation of the pieces from the board means that each different set of pieces defines a different game, and this is true independent of the nature of the board or game world. For us this means that to write a different game we have to actually code different pieces. The other thing to note is that different styles of play — different variations of the same game — can be built by changing the valuation or balance of a given set of pieces. This applies to our MUD system as well: without coding new entities we can tweak the game by altering the balance of inputs to the rule mechanics. As we code the game we need to note places where we are tempted to code magic numbers into our rules, game mechanics and entity code and always provide a way to insert any hard numeric values as balance settings instead.</p>
    <p>One somewhat surprising outcome is that the exact same engine and rule-set could be used to implement multi-dimensional versions of shogi, chess or checkers simply by changing the location interconnections to represent something other than a flat grid, without making any changes to the piece code or the game rules. We could make <a href="http://wiki.classictw.com/index.php?title=Main_Page" title="TradeWars 2002">ship-trader</a>,  <a href="http://www.wotmud.org" title="WoTMUD">D&amp;D</a>, <a href="http://www.bandainamcogames.co.jp/cs/list/batenkaitos/battle/index.html" title="Baten Kaitos">card-battle</a>, <a href="http://breakintochat.com/wiki/Operation_Overkill_II" title="Operation Overkill II">world-map/combat-timer</a>, <a href="http://www.mobygames.com/game/dos/pit_/screenshots" title="The Pit">sprite/glyph collision combat</a>, <a href="https://www.usurper.info/" title="Usurper">random encounter</a>, <a href="http://rephial.org/" title="Angband">dungeon-crawler</a>, or whatever other gameplay we might imagine. In the example case used in this commentary, though, we are building a traditional D&amp;D inspired MUD, but in your own explorations don't let that stop you from experimenting in wild directions.</p>
    <p>This business of separating the world engine from the rules is rarely done, mainly because the difference between the world as a platform and the gameplay as a mechanical system is usually not considered by game authors as they begin their design task. Part of the reason is that game design is a skill that is usually practiced under duress: business pressure, Christmas deadlines, the deferred rush for an American school break release, the company being acquired by new owners that know nothing about games or software, a culture that confuses typing with development, and any number of other human organizational weaknesses that detract from the task of understanding how the world, entity behavior and entity balance of a game system work together.</p>
    <h3 id="instance_data">Instance Data: Maps and Items and Characters Oh my!</h3>
    <p>Different gameplay systems, different worlds and different balance points describe a complete system but not an actual game. We need data that tells a particular instance of a game what it should look like. Things like map data, specific characters, items, their quantities, prices, those balance details discussed above, etc. are all game data. In addition to the base data that defines a particular instance of a game, there is player data and world state to think about as well. Any given MUD is going to be a unique combination of base world data (maps, spawn locations, NPC definitions, game scripts, etc.), player account data (login, character/account associations, etc.), and current world data (location of mob instances in play, object status, current objecta and mob locations, etc.).</p>
    <p>We have to decide how to split up the different types of data we will be dealing with, determine what is worth putting into persistent storage and what is OK to lose in memory if the whole system dies or needs to be restarted by the operator, etc. We also have to decide how the game system will save data and in what format, and more importantly, how operators who want to create a unique game world will populate their own maps, objects and mobs with whatever template entities we provide as part of the system.</p>
    <p>Different game worlds might have radically different themes. If we do a good job writing ErlMUD then a system operator who wants to set up an ErlMUD server won't need to know Erlang, won't need to know the details of telnet or TCP, won't need to be familiar with the vagaries of OTP or any other forms of modern magic. Anyone who wants to set up a server should be able to imagine a game world that complies with the mechanics of gameplay as defined in the system and write the details of the game world they want without messing about with these things.</p>
    <p>That means that the details of different types of mobs, where they spawn, what the map looks like, where traps, one-way doors, key mysteries, special effects (like magic or high technology), available items of what class, trade system, etc. should be something the system operator should be able to define without writing any new logic, so long as the world he envisions does not require the implementation of new system or gameplay features (making extra feature impementation easy will be an outcome of a clean design, and probably not achieved in the first few versions). This means one ErlMUD based world might be a Tolkien-like place full of goblins, warriors, elf princesses or whatever else, another might be a postapocalyptic world of survivors, mutants and zombies set far in the future, and another might be a Western full of dangerous outlaws living in the Badlands of Cyber New Mexico.</p>
    <p>One consideration with the building of worlds is whether we should build tools for creating the world, a facility for world creation within the MUD itself (a specially-priviledged player being able to spawn rooms and things on the fly), or just let the sysops deal directly with text files that contain settings information. Right now it doesn't really matter, but this will be something to consider later on. The easier it is for a sysop to express what they want the better we are doing in building a system that users will actually care about.</p>
    <h1 id="distillation">Distilling Elements</h1>
    <p>From the description above, and from taking some time out to play a MUD or two (seriously, try one), we can determine that the simulated world elements we need to deal with are:</p>
    <ul>
      <li>locations</li>
      <li>objects</li>
      <li>mobs</li>
    </ul>
    <p>We can defer the gameplay rules by making them apply to external gameplay modes. For example, combat rules can apply when a mob is "in combat", a trade or barter subsystem can apply when a mob is "in trade", and so on. This way each mode essentially represents a mini-game that fits smoothly within the context of the world simulation, and we don't have to care what sort of combat, trade, spell creation, or other mini-game modes are available within the world so long as we know ahead of time that we want a form of those systems included in some way.</p>
    <p>While we can defer specific operating rule mechanics until later, we can't completely ignore the instance data. At the very least, we need a way to create a skeleton set of game world data so we can try out on the different elements of the world simluation and actually have something happen. In the same way that the initial focus is not yet on the gameplay mechanics it is also not on the instance data at this point, so for now all we're going to do is create a simple way of passing a list of terms to some init function and that will suffice for now.</p>
    <p>We've discussed the game system, but not the scaffolding necessary to get the thing spun up. We'll go into more detail about this later on, but for now some obviously necessary system elements are:</p>
    <ul>
      <li>telnet interface</li>
      <li>chat system</li>
      <li>player registry</li>
      <li><code>erlmud:start/0</code> — it has to go somewhere!</li>
    </ul>
    <p>So far, this is what we can see. Let's take a closer look at the world simulation elements and system scaffolding and think through what supporting elements we might need to implement.</p>
    <h1 id="world_elements">World Elements</h1>
    <h2 id="locations">Locations</h2>
    <p>A location is a self-contained place within the game world where actions which immediately affect mobs take place. Our guildeline is that if a mob performs a physical, verbal, or emotive (or "emote") action it should only be visible to or have a direct effect on another mob in the same location. This should be distinct from the chat system and probably most other actions that can occur at a distance.</p>
    <p>There are two basic ways to implement locations. They could be entries in a universal registry where mobs, objects and associations among locations can be tracked in tables that indicate their relationship to the location. Alternatively, they could be processes which do their own entity tracking and are directly responsible for arbitration of physical actions.</p>
    <p>If we use a global-registry then we have the problem that nearly every action in the world depends on this registry. If this were done in a single process it would be a pretty busy one, but guaranteeing consistency would be relatively simple. If it were done in a worker pool the load could be distributed, but consistency would be much more difficult to guarantee and the registry store itself would still be a bottleneck. Either way, we would be putting all our eggs in one basket. If this registry were to die so would the MUD.</p>
    <p>Consider how complex such a monster registry would become over time. Once we give too much responsibility to a single piece of code the tendency is to increase the number of responsibilities it handles over time. This is against every good practice we know as engineers, but under the pressures of real life, business, and expectant users this is what tends to happen. It is quicker to hack "just one more" feature into an already overloaded system than to sort out the tangle of responsibilities and then implement an additional feature orthogonally. One Registry To Rule Them All is actually a pretty normal design in an OOP or imperative style MUD, but I don't think its a good fit for Erlang.</p>
    <p>The other way, where each location is a process, seems more sensible to me. If locations are processes then we avoid creating any bottlenecks and crashes can occur at a small enough scale that we can probably recover from them without affecting. This design is also easier for me to reason about because it is closer to being a genuine simulation of a world. This is the way we will try first.</p>
    <p>Each location will need to keep track of whatever mobs, objects and connections to other locations are present. If a mob, object or adjacent location were to crash the location should carry on. The location's job is to arbitrate activity within the location (someone closes a door, drops an item, etc.), answer queries about its current state (who/what is here, what exits are available, etc.), and broadcast location-wide notifications (a mob enters the room, says something out-loud, etc.). This is a fairly simple list of responsibilities that we can probably model in a single process without getting confused.</p>
    <p>There is a lingering problem, though. Locations will need to keep track of the status of adjacent locations and arbitrate the movement of mobs between themselves and those other places. This means two identical processes will have to communicate, and this communication will need to be synchronous. That means we need to watch out for deadlocks. (Oh noes!)</p>
    <p>My way of avoiding this kind of deadlock is usually to create another type of process that takes care of the synchronous communication on behalf of one of the two processes. This lets me design a protocol that at least isn't guaranteed to have a deadlock built in (whether our protocol actually avoids deadlocks is a different issue, but this way at least we're not guaranteed to have one).</p>
    <p>In this case I think it makes sense to create a "way" process that represents a one-way path between two locations. This lets us create interesting maps without adding new logic the locations themselves (one-way portals, for example), and it also gives us an easy method for implementing other game elements like shuttable/lockable doors, hidden paths, temporary portals, fuel-operated warp gateways, or whatever. Separating the idea of a "way" from a "location" gives us a lot of advantages both in terms of modeling the game world and in preventing kinks from emerging in our messaging protocol.</p>
    <p>So there we have it, we've identified our first "unseen" element: ways. We'll worry about the details of ways a little later on, but its good that we have identified that locations do not stand alone within the game system.</p>
    <p>Something we glossed over up to now is how to instantiate the locations. Where do they come from? Since we will probably have a map defined in permanent storage that gets pulled during startup/reload a traditional system of supervisors that manage workers will be a good fit. We can assume, then, that we'll probably need at least a "location manager" process that spawns locations and restarts them if they die untimely deaths. There might be other things we want this process to do, like alter the map dynamically, but we don't have to worry with that for now. At this point it is sufficient to say that our second "unseen" element is a location manager that supervises the locations and that the locations are workers at the bottom of the supervision tree.</p>
    <h3 id="locman">Location Manager</h3>
    <p>Manage those locationses.</p>
    <h3 id="ways">Ways</h3>
    <p> In particular, the issue of how locations know its safe to permit a mob to depart to a certain adjacent location, how it knows the adjacent location's process is up, and how to handle the concept of open/closed/locked ways or doors to other locations has been left unaddressed, but that little sense programmers often have that something is not quite as simple as it seems on the surface is telling me that this area of functionality is both complex enough that it requires its own logic and orthogonal to the basic duties of a location to justify being placed in a separate module.</p>
    <h2 id="objects">Objects</h2>
    <p>Any inanimate thing in the world that can be manipulated is an object: weapons, armor, consumables, light sources, money, clothing, food, containers, etc. Different types of objects may have special behaviors, like food that spoils over time, or a weapon that wears out or a piece of clothing that can only be worn on the head. Objects need a way of being created, destroyed, picked up, placed in containers, act as containers, used as ingredients or food, and any other in-game action we might come up with.</p>
    <p>This tells us that the design of objects is not as easy as we may have initially thought, and may not even fit within a single definition. Perhaps a food object should be defined differently than a weapon object, but adhere to a similar generic interface of "object". Maybe objects should be a central digest instead of being processes. We're not sure at this point, but it is certain that being able to interact with game-world objects in a natural way is a system requirement.</p>
    <p>I've got three basic ways in mind about how to implement objects. One is to make a central object registry that keeps track of all objects across the game world. Another is to do things the C-style MUD way and have a library of object type definitions we can copy into structs based on the type that is needed, and mobs, locations and container objects could pass pointers to those structs around to represent associations that they track themselves. And yet another way is to make every object a process of its own, the way we do with locations.</p>
    <p>The central registry style suffers from the same problems a central location registry would, so that's out. If we thought a location registry would become a bottleneck and complex to implement, imagine how busy an object registry would be! There is a lot less travel and position checking in a MUD than object-influenced activity (every combat action might take weapon and all clothing/armor stats and total carried weight into account, for example), not to mention the variety of behaviors that would have to be coded into the object registry to implement diverse things like ingredients, food, equipment, etc. No thanks.</p>
    <p>Passing pointers around would be nice, but this isn't the way Erlang works: we can't share memory. The entire tuple representing the object would have to be passed between locations, mobs, and other objects as messages, and each of these process types would have to know how to interact with them. (For the curious: Screwing up the procedure of passing pointers or creating/destroying structs/objects to represent item passing is the source of many an item dupe bug.) If the shape of the object data ever changed, that would cause a lot of surgery throughout several other modules. Record syntax could help us there a bit, but then we'd have to share record definitions across source files, and that gets wonky. A better way would be to wrap the object data behind a functional interface, and this might be a workable solution. But where would we put the influences of objects themselves? Let's say we want to implement food that decays over time. We will need to write some logic in location code that updates the state of the food it contains to effect the decay, and we will also need to write very similar logic into mobs and container objects to make sure the same things happen there as well. And where is the code for container objects now? This is actually not sounding like such a good idea. Its simple to think about passing a tuple that represents an object in the game world, but not so simple as soon as we want those objects to exhibit some sort of behavior of their own.</p>
    <p>That leaves us with designing objects as their own processes. This lets us do all sorts of cool stuff, because we can code "object logic" directly into them and give them their own processing loops, timers, state, etc. But what about the different categories of objects? How do we make food, weapons and containers fit into the same definition? We might not be able to. I'm not so sure that objects will fit into a single definition, we may actually need several to keep our code understandable. But that's OK, because there are no constraints on process type with regard to message passing.</p>
    <p>What we really need is a messaging protocol for objects. That way objects of a certain type can identify themselves if necessary, have their own behaviors with regard to messages received and sent, and all look basically the same from the outside despite their internal differences. (Sound a bit like "duck typing"?) An oven could be a finite state machine, a container a service process, and food could be some new "food behavior" we have yet to invent. The point of defining objects as a protocol and not some specific process type is that it permits us to defer the details of any particular object type until later. We can play with this protocol early on by creating some generic object type at the outset which will grow to represent our basic object message protocol, and keep in mind that implementing special object types will require new modules that adhere to the basic protocol. Of course, to design a protocol we have to determine what to talk about first, and that means we have to establish some basic attributes common to all objects.</p>
    <p>Here we have two unseen elements: generic object attributes and the object messaging protocol. We knew at the beginning that we wanted to have objects in the game, but until now it wasn't clear that "objects" would have to be a category of process definitions which adhere to a messaging protocol as opposed to a single type of process or data structure.</p>
    <p>It might seem strange to leave the question of whether potentially tens of thousands of object processes sitting around in memory, maybe noisily messaging each other all the time will be a problem later on or not. In an OOP type system this might be rather hard to fix later on if not designed out of the system right now. Gobs of dependent calls sprinkled throughout the code might have to be fixed. But I've found in my experiences with Erlang that its usually best to blithely assume that the "everything is a process" concept will work out fine (unless there is some really obvious reason it won't), and that fixing performance issues only makes sense to worry with once some hard performance data from the actual development system we're working on is available. It is relatively easy to switch message routes around and replace the representation of components within even a relatively complex system. A big part of this has to do with the way we will encapsulate the data we are working with, and Erlang's refusal to let us share anything between processes helps prevent us from coding ourselves into a troublesome corner in this regard.</p>
    <h3 id="object_attributes">Object Attributes</h3>
    <p>Here we want to iron out two things: what are the aspects of all objects that can be interacted with, and what attributes must all objects exhibit in order to adhere to the common model of interaction. If we don't think through this part we'll never be able to create a coherent object protocol. Actually, even if we do this part, our object protocol will still be ridiculous at first, but it will at least be something other than completely stupid (like forgetting that food has weight because we only thought of weight in the context of encumberance penalties for armor or whatever).</p>
    <p>Objects are made of matter. Let's start there. Matter takes up space and has mass. Mass means weight. Space means volume. We could work these into the game system without overcomplicating things. Or could we? If we implement volume we will also have to implement volume checks everywhere (object A is light enough, but not small enough to fit into container B, etc.). That's probably not so hard to do, but its a bit more detail than most games worry over. Gameplay tradeoffs will definitely become more complex if we include volume considerations, which could be bad, but it could also result in really interesting decision making for players. We shouldn't forget about this volume idea, but for now I just want to stick with weight as a basic property of objects.</p>
    <p>Objects also have to have a name, and maybe a description that gives a bit more detail. For example, a player targets a rock by calling it a "rock" but when he performs an examine or look action, maybe a more interesting description of the rock should be displayed. So we'll include descriptions, since descriptions are our only way of conveying anything about the game world to the players, since we're not implementing any graphics.</p>
    <p>So there we have it, at least for now: objects have a name, a description and a weight. All objects exhibit these properties, regardless of type. We can implement a very primitive game world where this is true, and come back and make this more interesting a little later if we find it necessary.</p>
    <h3 id="object_protocol">Object Messaging Protocol</h3>
    <p>The basic object protocol needs to be general enough that every object of any type can conform to it without making things ridiculous, but not so specific that it interferes with whatever unique things a special object type should do. There is no doubt that the protocol itself will have to get ironed out a bit as we go along, but a good place to start with building a message protocol is basic interrogation of the object's properties. This is something we have a head start on since we already decided what the most object attributes are.</p>
    <p>Let's take one step farther than just writing a gigantic flat protocol space that looks like <code>{From, some_very_specific_request_atom}</code> and break things up a tiny bit. Objects don't really do anything, at least not basic ones. Objects don't need to know where they are, who owns them, or whatever. If we decide to implement a concept of natural ownership (the way items in <u>Oblivion</u> maintain an owner tag) then maybe it would be useful to add a way to update this, but for now we don't care. So we can get away with having the mobs and locations deal with tracking where objects are, and only worry with having a way to ask an object about its basic attributes.</p>
    <h3 id="objman">Object Manager</h3>
    <p>Manage those objectseses.</p>
    <h2 id="mobs">Mobs</h2>
    <p>Finally. the focus of the game. Mobs are what do the verby things in MUDs. They are the world creatures, the NPCs, the player avatars, the predators and the prey. Every beast, player, NPC, demon, perpetually kidnapped princess or whatever else we decide to include in the game world that is alive falls into this category. Anything that is attackable, killable, aggressive, prone to flee, talk-to-able, bound by in-game laws, factionalizable, grouppable, emotionally conscious, ridable or ownable as a pet, passengerable, or definable as friend or foe is a mob. Without them the MUD would be a pretty boring place.</p>
    <p>Knowing that all the above types of actions and attributes center around mobs indicates that while a general definition of mob may suffice at the outset, mobs will likely also require a message protocol definition that lets us write a variety of mob types that do different things but interact with the system in a similar way. This isn't so different from our discussion of objects, above, really. The main difference is that while it wasn't so obvious at first that objects should be processes, it was always clear that mobs would be. In both cases we find ourselves settling on an initial, generic implementation of each so we can explore the message protocol in more detail, knowing that we will almost definitely be writing a few unique modules that adhere to that protocol later on.</p>
    <p>The similarities between objects and mobs only goes so far. They don't do anything so they don't have players or AI controlling them. Mobs do things. How do we make those actions happen? What determines what action happens when? If we put a dog mob somewhere, will he ever leave? Will he chase rabbits on his own? Where does that go? Do we re-write a new module every time we come up with a new mob type (and then have to change all thousand of them if we ever decide to change the mob messaging protocol? Ouch!)? Something is clearly missing here. We need a controller.</p>
    <p>While it would certainly be possible to write the AI elements directly into a mob, that would pose some problems. For one thing, every mob would need different AI or else the world will be remarkably inflexible. Having an evil miniboss and the town blacksmith share the same AI would pose a problem. It also limits our options: what if we want to create a game world where all the mobs already pre-exist, and players just take control of mobs in place and play that way? Its not traditional, but its an exciting idea. What if game staff (usually called "immortals" or "imms") want to enhance roleplay possibilities temporarily by taking control of a village NPC and providing some live interaction? We can't do those things very easily if the controlling code and the mob code are intermixed. Well, to be specific, it might be possible to implement that sort of a system exactly once and never change it again, but smooth evolution of a codebase is one of the most important things we have to think about as developers, and its no good to tie a big Gordian Knot of concerns right from the start (though this seems to be the norm in many projects).</p>
    <p>To perform actions mobs will have to know where to send messages that represent or initiate actions, be able to somehow observe their situation in a reliable way, maintain an inventory, know what state they are in (awake, sleeping, in combat), have some mechanism of determining the effects of received offensive and defensive actions balanced against ongoing effects that influence the impact of such received actions. This implies that mobs must have some mechanism for being spawned, being hurt, being healed, dying, and being respawned.</p>
    <p>But that is just life and death. The whole range of things that occurs between a mob's spawning and its death is what we are really interested in. How do mobs communicate? Not in the sense that their processes send messages to other processes, but within the semantics of the game world. Can a player's avatar talk to another player's avatar? How does this happen? Obviously mobs other than players are going to move around. Where are the decisions for the NPCs made? Within the mob model, in some global process that controls everything players aren't controlling, or by some other process? Critically for us as programmers, we have to find some design that makes the interface between mobs in general and other elements of the game world as perfect an abstraction as possible, so that the design of locations and objects will not have to take into account whether the mob processing sending it a message is an NPC, a player, or some other mobile entity. This is not terribly hard once we realize how important this form of abstraction is, but if we hadn't thought things through this far and simply sat down to write out the entire game system in one huge module we would quickly find ourselves in trouble.</p>
    <p>This idea that mobs must be abstracted from other elements of the game world, and that mobs must have some mechanism for making decisions brings up an interesting aspect of Erlang design. Let's consider the difference between an NPC and a player character. A player character is connected to a player across the network somehow and this player is making decisions in his mind and sending commands back to the mobs which it is acting upon. The NPC is somehow making decisions on its own. We can either design two completely different mob modules, one for NPCs and one for PCs, where the NPC contains some AI mechanism and the PC contains some network connection handling code. This requires we develop a strict protocol or interface definition among the game elements that are considered mobs, and adhere to it within the design of both NPCs and PCs. Locations and objects would have no way of knowing whether they are communicating with an NPC or a PC so long as the communication protocol perfectly abstracted the concept of mob. The other way of doing things is to design a generic mob concept which knows how to interact with the world and to accept commands (like the PC mob above, but without the network code), and then develop a "controller" sort of process which might be a "PC controller" type that knows how to talk to players and an "AI controller" type that knows how to make NPC decisions.</p>
    <p>Whatever we decide, it will have an impact on how development will go and how easy it is to change things around in the future. If we create two different mob types, then the protocol that both mob types must adhere to spans every point of interaction with every other game element. This is burdensome if we want to implement mounts, for example, because every place that relates to mount implementation will have to change across both the NPC and the PC code. in most code this is handled by slowly crippling the functionality of NPCs in favor of spending development effort on adding features to PCs. If, on the other hand, we develop a general mob process and then place a controller behind it, we can much more easily develop a flexible system. With such a design it would even be trivial to permit players to take over control of mobs in progress, or pass control of their characters to AI controllers in the middle of play instead of renting a room at an inn or simply idling out in space. This sort of design is not just better because it will ease our burden as programmers, but its better because it enhances the options for how the system can be made to behave.</p>
    <p>Controllers and mobs will be discussed in more detail later on.</p>
    <h4 id="mob_attributes">Mob Attributes</h4>
    <p>We already know that mobs are the active force of the game and since we're writing a game system that implements a character-based D&amp;D style system that character traits are what determine the outcome of nearly every action. Mob attributes are not going to be simple. But we aren't yet concerned with implementing the game system in full just yet. We haven't even discussed the combat system or weapon/skill calculations or whatever. We don't care about these things yet. What we need to do before we think too hard about any of those things is to get a basic game world working where mobs and move around, talk to each other, use the chat system, manipulate basic objects, and be controlled by a basic AI or basic player controller. That's it. If we get these parts correct, implementing a combat system on top of it should not be hard. The hard part about combat systems are the combat systems themselves and the interactions among all the factors that go into a combat action calculation. I don't even want to think about that until we've got a basic system functioning. That's trying to establish the game system for chess before you've even determined how the board works.</p>
    <p>One might ask why we are setting our sights so low. My answer is that this is simply the software version of going ugly early. Sure, if an opportunity for improvement comes along later we'll take it, but for now let's stick with what we know will be reliable, and then build upon that.</p>
    <p>So what are basic mob attributes? It might be a good idea to make them similar to basic object attributes: name, description and weight. Actually, we can leave weight off for now, because we don't care. If we don't care about a mobs D&amp;D style stats yet, we also don't care about the weight of it. At the moment we care more about what mobs do than what they are, so we'll just leave it at that.</p>
    <h3 id="mob_protocol">Mob Messaging Protocol</h3>
    <p>The mob protocol is a bit of a complex thing to discuss. The reason is that mobs are the hub of nearly all interaction in the game. Being the center of activity means that mobs define as many protocols as the number of unique sorts of activities they engage in. We should start with just the basics to permit a "live" game world to exist without getting too far down into the weeds.</p>
    <p>We want to start with just a few requirements: movement, observation, object manipulation, and communcation. That's it. We're leaving out all sorts of stuff: trade, combat, equipment, time, thieving, justice, etc. and just about every other conceivable gameplay element we might want later on. That's because we're just working on the game world right now and not the gameplay (much less building an actual game on top of all that yet).</p>
    <p>Let's think through these for a moment. Movement is probably the most complicated thing to implement because it involves a collection of processes working together to accomplish a task. If we put a mob into a location and it wants to move, we need some way to indicate this to the location, then the location must check that the mob really is in the location, that the outgoing way is open, and then the way itself must let the receiving location know who is coming. The outgoing location needs to confirm that it dropped its record of the outgoing mob and the incoming location should confirm it somehow. We could combine the dropping from one location and confirmation of the drop without any issues (the mob doesn't care if it is locationless for a moment), and we can combine the incoming location's receipt of the mob with adding it to the new location's state. But this remains a non-simple chain of interactions to effect movement and it must be synchronous so that we can handle special cases in the future without encountering wacky corner asynchronous corner cases (like travel-related messages arriving really late, or the outgoing room sending a mob into empty space because it receives no confirmation of mob receipt, etc).</p>
    <p>Manipulation will be much easier than this. A mob should be able to get, drop, and check its inventory of objects. That's it. When something is picked up, it should be removed from the location's inventory. When it is dropped it should be added to the location and removed from the mob. Not too hard a task, but one which once again must be synchronous to prevent weird cases where a location is just adding random objects to itself based on asynchronous receipt of old messages. Making this synchronous also means that two mobs can't get the same thing at once and accidentally dupe it in the process, because the location will block on the pickup message, remove the object, and then handle the other mob's get action message.</p>
    <p>Chat would be hard to implement if it were synchronous. But it won't be. Ha ha! We'll just be simple for now and fire chat messages off into space and assume everything works out. With a bazillion chat messages flying at once I don't really care if one gets lost, and it won't crash the game system. Anyway, the Erlang runtime guarantees delivery of a message so long as its target is alive, and that is really all we care about. This promise is actually quite amazing, and makes it very simple to create things like chat systems. But the chat system is not critical to the game world, just the users. I want to focus on making the world work first, then the chat system, so that's what I'll do.</p>
    <h3 id="controllers">Mob Controllers</h3>
    <p>Yikes! Network and AI code in the same spot!</p>
    <h3 id="mobman">Mob Manager</h3>
    <h1 id="scaffolding">Scaffolding</h1>
    <h2 id="telnet">Telnet interface</h2>
    <p>MUDs traditionally work over telnet and do not require any special client-side software. We will follow this tradition in ErlMUD, at least for a while. It is common for clients to be written that understand a particular MUD or MUD family's textual structure, commands, alias system and map representation, and simply use the telnet protocol to connect on behalf of the user. Using TCP sockets is easy enough in Erlang compared to C that its tempting to break with tradition and just write a new TCP protocol and a client and server of our own on both ends. We're not going to do that, at least not yet. The reason is that telnet is easy, and easy is a good place to start when writing a new project with a design that is untried. I'm pretty sure I can get the internals of the main MUD elements to work, at least in a hackish way, without too much trouble. I'm also pretty sure that if I mess with it a bit I can host write a telnet server (should be a lot easier than doing it in C in the past). This is already a significant amount of work to do, and both are things I've never tried before. I don't want to add a new network protocol, a whole new application (the client software), an installer or package(s) for that client, and a way to get the client to users to the list of things on my plate just now. We're not even into the code yet. If any feature isn't absolutely essential we should consider if its something we might want to write it down, and then forget about it (hopefully forever).</p>
    <p>Telnet is a pretty simply protocol, but, as indicated above, may not be the only way we will connect to the MUD. Consider that even without client software we might want to be able to connect over a secure channel instead of Telnet, since Telnet is all plain text, including passwords (oh no!). So designing the system so that the telnet connection is a component that the main service manages, and not a bunch of networking code written directly into the main system loop, is a good idea. That gives us options, and even if we never exercise the option to connect through some other method (consider how nice it would be to connect directly from an Erlang shell on another node...), it will force us to do the right thing early on and separate the detail of how we connect to the network from the fact that we connect to the network.</p>
    <h4 id="chat">Chat system</h4>
    <p>Chat is one of those things that isn't arbitrated by locations, globally accessible, and not an option. There are a few things we have to think about when implementing a chat system. For one thing, each location is sort of its own little chat server, since all verbal and emote activity is visible to other occupants. We might want to implement something like a "shout" feature, where any really loud action (like an actual shout) can be heard to all occupants of locations within a zone, or maybe heard X-locations away. We might also want to mimic a fun feature of WoTMUD, where players of two different species can only understand their own kind but still share basically the same channels.</p>
    <p>Channels? Hrmmm. That's a lot like locations again. So the real question is, how do we prevent ourselves from duplicating a ton of code? Another issue is whether a mob joins a channel, a controller joins a channel or a player's connection handler farther up the stack joins the channel (and is the player's connection the same as the controller?). Previously we had established that mobs require controllers and that separating controlling logic/interfaces and the mobs themselves is probably a good idea. Now we come to the question of "what part of a mob has ears and eyes?". I think it makes the most sense to give the mobs themselves the sensory organs, route chat messages along to the controller the same way other observations are, and let the controllers handle or disregard messages as needed. Then I can avoid writing any special case code into "chat listeners".</p>
    <p>What about private messages, like "whisper" or "tell" features? Its easy enough to implement a "tell" that makes one mob send a chat message directly to another mob, bypassing anything else. We can even say that each mob maintains its own "ignore" list and avoid having to write a central nanny message arbitration function. But this issue with ignores, private messages, channels, listening for shouts, emotes, verbals, etc. is already demonstrating that chat is actually not such a simple part of the game, simply because targetting, routing, listening and filtering are all issues we start having to suddenly deal with.</p>
    <p>Actually, I don't want to put this into the mob's core logic. I really want to just have a single message tag, like <code>{chat, From, Message}</code> and have <code>Message</code> contain the message itself and a meta message that we can perform filter, routing, etc. logic on. And I don't want to write that logic into the actual mob processes themselves, because I'm pretty sure the metabolism and combat system is going to fill quite enough lines of code as it is. So we should write a second, assistance module for mobs that behaves like their sensory organ. Chats can either target that directly, or target the mob and the mob pass its message into it asynchronously (this is the kind of process I would link, so its logically a part of the mob, and if either crashes the whole mob crashes), and the sensory process can take over from there.</p>
    <p>We need to write a system of channels which can be created, joined, left, and moderated. This will probably look a bit like the way locations are implemented, but without all the extra logic of physical arbitration, travel, or anything else hard. We don't need a map, either, but we may want to define some boundary conditions for chat channels, like default instantiation of factional or race-based chat rooms or something of that sort. To begin with, though, we should probably aim low and write a single global chat channel, then once we understand that, add another, and then add an in-game way to identify who should automatically belong to faction-type channels, and make a way for players to create channels in-game as well.</p>
    <p>So that's the plan for now: first get a simple, global broadcast type chat working, and diversify from there based on whatever features we decide to implement later on. At first, anyway, with zero or very few players we won't really need to do much with channels, so we can keep in mind that we want to implement channels later on, but skip doing anything with that idea for now.</p>
    <h4 id="player">Player registry</h4>
    <p>People have to have some way of identifying themselves to the game server so that it can locate their character. Or not. We might want to design a game world where every time you log in you randomly inhabit a pre-existing mob and engage in whatever is going on nearby on your own. This is actually a pretty interesting idea, so I'll write it down, but for now I'm going to do the old-fashioned (and not very secure) username/password way of doing things.</p>
    <p>But do players have accounts and characters, or is every character an account? Mobs will certainly have some concept of points or level status or something, but is this different than an account system or is the character system itself all there is to the account system? I like the free feeling old MUDs give by making characters painless to create and totally independent of one another with no account system above this. On the other hand, players today are pretty used to the World of Warcraft account model where one account owns several characters. The problem there, of course, is that if your account gets compromised all your characters are compromised at once. Its a player-side version of putting all one's eggs in one basket, which is good to avoid. Perhaps a good middleground is possible, where we create an account system, where each account owns only one character, but make it possible to add additional characters later on, but just not implement the command functionality for that yet.That means we need player accounts, and they need to track what mobs they own.</p>
    <p>So that's two things to implement: a storage system for persistent character data (whatever the system remembers of you when you "rent" or logout), and an account storage system for tracking account/character relationships.</p>
    <h4 id="erlmud_start">erlmud:start/0</h4>
    <p>Any system needs a way to get started. Some folks write this module in as much detail as they can first, and then work from there down to the details. Some folks work on the tiny components first, assembling their code from little blocks as they go. I mostly do the top-down part, but don't spend much time on detail at the highest level. Instead I usually write a <code>somapp:start/0</code> function that barely suffices to spawn a unique process, and then revise from there as I go. I've decided that this prevents me wasting time on too much detail that I don't have any hope of understanding just yet. It also allows me to be lazy at the high level and geek out at whatever level of the problem interests me first, so long as I am diligent enough to fill in the execution path between <code>start</code> and whatever I'm working on.</p>
    <p>This is one place that it can be good to start trying to iron out the verbiage of your project very early on. Write your initialization bits in a way that deals with your major system components at the level of abstraction you want the rest of the world to. Starting this early on forces pushing details to other modules, particularly in the case of whatever data models are used to start up the system. The last thing we want is for whoever configures the system and might actually deal with some top-level component to have to know that object state is represented as a tuple of form X underneath. Yuk.</p>
    <p>I'm going to leave this one wide open for now, and only implement a direct code path that spins up the application and phrase things in the initialization procedure in a way I think is natural. It will probably be wrong, or at least not look much like whatever the production version of this module will look like, but that's OK for now.</p>
    <h1 id="summary">Summary</h1>
    <p>Whew! That's quite a bit of stuff. Its enough that I think we need a quick summary of the bits above, just so we don't get overwhelmed by all the detail and rambling thoughts that passed above. The system is still quite small, after all.</p>
    <p>Game elements:</p>
    <ul>
      <li>Locations</li>
      <ul>
        <li>Ways</li>
        <li>Location Manager</li>
      </ul>
      <li>Objects</li>
      <ul>
        <li>Object Attributes</li>
        <li>Object Messaging Protocol</li>
        <li>Object Manager</li>
      </ul>
      <li>Mobs</li>
      <ul>
        <li>Mob Attributes</li>
        <li>Mob Messaging Protocol</li>
        <li>Mob Controllers</li>
        <li>Mob Manager</li>
      </ul>
    </ul>
    <p>System elements:</p>
    <ul>
      <li>Telnet</li>
      <li>Chat</li>
      <li>Player Registry</li>
      <li><code>erlmud:start/0</code></li>
    </ul>
    <p>At this point we have a firm enough idea what the primary game elements are supposed to do that we can begin sketching them out in pictures or very simple (psuedo)code. In the next section we'll start implementing very simple versions of each of these pieces in an order I think is reasonable, and add code a bit at a time until we have a very basic world simulation engine in place.</p>
  </div>
  <div id="footer">
    <div id="nav"><a href="000-001_introduction.html">&lt; Previous</a></div>
    <div id="nav"><a href="index.html">Home</a></div>
    <div id="nav"><a href="001-001_concept.html">Next &gt;</a></div>
  </div>
</body>
</html>
