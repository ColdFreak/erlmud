<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" />
  <title>ErlMUD Notes: Concept | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="concepts">ErlMUD Concepts</h1>
    <p>ErlMUD is a simple Multi-User Dungeon that runs over telnet, inspired by joyful memories of playing dialup BBS door games and MUDs before the advent of residential internet. It is written in a way that takes advantage of Erlang's concurrent, strict message-passing model and the few promises provided by the Erlang runtime.</p>
    <p>This commentary follows the development process of ErlMUD as it undergoes changes, feature additions and design evolutions. The code is written several times iteratively, gradually adding features and — most importantly for the purpose of this project — evolving in terms of code style from a primitive system of limited functionality to a full-blown production system that would (hopefully) not drive future maintainers mad.</p>
    <p>This chapter begins by discussing some aspects of design that are common to any project, details the primary elements necessary to create a MUD game world, and then discusses secondary elements and other "unseen" aspects of the project which are necessary for implementation. The purpose is not to hash out every detail in prose, but rather to think about the problem in a general way and discover some of the unobvious issues that will have to be dealt with in order to implement the game system. The goal of the implementation is to elevate the primary game elements to the level of abstraction that we want to deal with so we can dispense with the details under normal conditions.</p>
    <h2 id="elements">Elements</h2>
    <p>In any project there are two categories of elements. There are those elements which obviously must be a part of the design, and those that require discovery on the part of the developer.</p>
    <p>The obvious parts are clear to us either because they represent a resource we know is required beforehand or because interacting with these elements is the purpose of the program. At the outset of the project this is what is seen.</p>
    <p>There are other elements, however, which are not so obvious and must be discovered through exploration and experimentation. The exploration part involves working through the problem space, discovering exactly what it means to handle the problem. The experimentation part consists of trying different methods to handle the problem and evaluating the resulting system by some balance of criteria to determine the "right" design (or, more often, the "least wrong" design). As the problem is explored and little experiments progress developers will come to the inevitable realization that handling the problem is not as easy as it initially appeared, that too much understanding of the problem was assumed at the beginning, and that previously unconceived elements are necessary to deal with the problem. At the outset of the project this is what is not seen.</p>
    <p>The "seen" bits represent a basic description of the problem and the "unseen" bits represent the implementation. This is analogous to the difference between reading the definition of a square root and coming up with an algorithm to derive them. Erlang is a very high level language in many respects, but it is not so advanced that we can simply plug in a mic and demand "Make me a system that does X!" and get what we want.</p>
    <p>When writing software for ourselves we usually know what features we want and can quickly enumerate the "seen" bits. It is our lack of understanding of the unseen bits that bites us in the ass later. (The "unseen" ass-bitings come in a striking variety of forms!) When writing software for customers, however, the most frequent problem is that the customers are themselves not able to "see" the parts that should be initially "seeable". (Some customer engagements can be quite a rodeo...) The solution most programmers have adopted is to jump ship just after initial release and leave users and future maintainers to discover the need for Kevlar underpants on their own.</p>
    <p>The fact that there are obvious and unobvious elements of the system is part of why projects must evolve as they move forward. Sometimes an "evolution" means simply tweaking an interface or adding some method of type checking to catch latent mistakes early, sometimes it means radically changing a data schema, and sometimes it means a general re-write because we discover that a current approach is not working (or often that it works, but is unbearably costly to pursue). We will see a broad range of evolutions as ErlMUD grows.</p>
    <h3 id="seen">That which is seen</h3>
    <p>"MUD" stands for "Multi-User Dungeon". MUDs are text based adventure games, usually accessible via telnet or ssh, and provide a line-based text interface. Locations in MUDs are defined as "rooms" or "sectors" which are often grouped into "zones" which share some common behavior. Entities in MUDs are animate "mobiles" (or "mobs") and inanimate "objects". A player character is usually represented as a mob which is under a user's direct control. An arbitrary range of movement methods between locations is defined, often unique to each game system, and an arbitrary range of interaction and communication commands is defined between animate→animate and animate→inanimate entities.</p>
    <p>Combat is often a strong component of a game world, but in some MUDs chat, emotive actions or roleplay is the focus. In any MUD, whether combat or roleplay based, there is a strong user expectation of community involvement. The primary motivation of most MUD players is themed interaction with an online community, not mere interaction with the game world itself. For this reason many MUDs run for decades with the same general player base. Most MUD systems are usable as backends for either combat/adventure or chat/social servers. In a certain sense, MUDs can be considered super-advanced chat servers, though it seems that most MUD authors do not think of them in this way.</p>
    <p>From the description above, and from taking some time out to play a MUD or two (seriously, try one), we can determine that the primary game elements we need to deal with are:</p>
    <ul>
      <li>locations</li>
      <li>objects</li>
      <li>mobs</li>
    </ul>
    <p>While the other system elements that are obviously necessary are:</p>
    <ul>
	  <li>telnet interface</li>
      <li>chat system</li>
      <li>player registry</li>
    </ul>
    <p>So far, this is what we can see. Let's take a closer look at each of these and think through what supporting elements we might need to implement.</p>
    <h4 id="locations">Locations</h4>
    <p>A location is a self-contained place within the game world where actions which immediately affect mobs take place. As a general rule, locations define the boundary of interaction among elements. Examples of exceptions to this would be mob→mob chat messages, a mail system, effects that work through "zones" (weather? magic? nukes?), magical spells or in-game technologies that locate or affect entities at a distance, etc. — if we decide to implement such things. If we can design the system so that implementing exceptional interactions is not impossible we will be doing ourselves a favor.</p>
    <p>This implies that if a mob performs a physical action it can only be visible to or have a direct effect on another mob in the same location. Further, if a mob "says" something vocally or expresses an emotional action (performs an "emote") it should also only be visible to other mobs in the same location. This should be distinct from the chat system and probably most other actions that can occur at a distance.</p>
    <p>There are two basic ways to implement locations. They could be entries in a universal registry somewhere where mobs, objects and associations among locations could be tracked by making (or having made) entries in a table or list of key-value pairs that indicates their relationship to the location. Alternatively, they could be processes which keep track of their relationship with other elements on their own.</p>
    <p>If we do things through a global-registry then we have the problem that nearly every action in the entire world depends on this registry providing answers about the current disposition of everything else. On the other hand, because a single process can only ever run sequentially, guaranteeing consistency is relatively simple. If this were done in a single process it would be a pretty busy one, if it were done in a worker pool consistency would be much more complicated to guarantee and the registry store itself would still be a very busy bottleneck.</p>
    <p>That would make the registry both rather complex and absolutely critical. If the sole registry that is tracking all entity relationships were to die, that would be the end of the MUD. There is no clean way to recover from that. The closest thing to a clean recovery path would be to have the registry save its state to permanent storage somewhere every time it did anything. Even if we were able to push the entire state of the MUD into permanent storage every cycle, a crash would still have a major effect on our users.</p>
    <p>It is important to consider how complex such a monster registry might become over time. Once we give too much responsibility to a single process, the tendency is to double-down on that over time instead of deligating responsibility among other processes. It is much easier to hack one more feature into an already overloaded system than to untangle the Christmas-light-ball of responsibilities and then implement an additional feature orthogonally somewhere alongside the others. One Registry To Rule Them All is actually a pretty normal design in an OOP or imperative style MUD, but I don't think its a good fit for Erlang.</p>
    <p>The other way, where each location is a process that does its own relationship tracking, seems more sensible to me. If locations are processes then location crashes can occur at a small enough scale that we can probably recover from them without affecting the entire game world, and we also avoid creating a game-wide bottleneck and operational dependency in the form of a global registry. This makes more cognitive sense to me. Such a design is closer to being a genuine simulation of a world than an arbitrary conjuration of a location data service which we would have to dress up behind a layer of other service abstractions to give the impression that a game world exists.</p>
    <p>If locations are processes then each one would need to keep track of what mobs, objects and connections to other locations are present and active. If a mob, object or adjacent location were to crash, the location could carry on and so could the game. The location's job would be to arbitrate activity within the location (someone closes a door, drops an item, etc.), answer queries about its current state (who/what is here, what exits are available, etc.), and broadcast location-wide notifications (a mob enters the room, says something out-loud, etc.). This is a fairly simple list of responsibilities that we can probably model in a single process without getting confused.</p>
    <p>There is a lingering problem, though. Locations will need to keep track of the status of adjacent locations, and arbitrate the movement of mobs between themselves and adjacent locations. This means two identical processes will have to communicate, and this communication will need to be synchronous. That means we need to watch out for deadlocks. (Oh noes!)</p>
    <p>My way of avoiding this kind of deadlock is usually to create another type of process that takes care of the synchronous communication on behalf of one of the two processes. This lets me design a protocol that at least isn't guaranteed to have a deadlock built in (whether our protocol design avoids deadlocks altogether is a different issue, though).</p>
    <p>In this case, I think it makes sense to create a "way" process that represents a one-way path between two locations. This lets us create interesting maps without adding new logic the locations themselves (one-way trap doors, for example), and it also gives us an easy method for implementing other game elements like shuttable/lockable doors, hidden paths, temporary portals, fuel-operated warp gateways, or whatever. Separating the idea of a "way" from a "location" gives us a lot of advantages both in terms of modeling the game world and in preventing kinks from emerging in our messaging protocol.</p>
    <p>So there we have it, we've identified our first concrete "unseen" element: ways. We'll worry about the details of ways a little later on, but its good that we have identified that locations do not stand alone within the game system.</p>
    <p>Something we glossed over up to now is how to instantiate the locations. How do they get initialized? Since we will probably have a well defined map defined in permanent storage somewhere, the traditional Erlang system of supervisors that manage workers will be a good fit. We can assume, then, that we'll probably need at least a "location manager" process of some sort that spawns locations and restarts them if they die untimely deaths. There might be other things we want this process to do, like alter the map dynamically, but we don't have to worry with that for now. At the moment, it is sufficient to say that our second "unseen" element is a location manager that supervises the locations, and that the locations are workers at the bottom of the supervision tree.</p>
    <h4 id="objects">Objects</h4>
    <p>Objects are things which are not mobile or alive. Within this broad definition of objects we find anything else in the world that might not be alive but is also not a location: weapons, armor, consumables, light sources, money, clothing, food, containers, etc. The idea that some items may have a limited lifespan, and therefore have a way of being created and destroyed, picked up, placed within containers, act as containers, and maintain enough state to influence other elements of the game system tells us that the design of objects is not entirely simple, and may not even fit within a single definition. Perhaps a food object should be defined differently than a weapon object, but adhere to a similar generic interface of "object". Maybe objects should be a central digest instead of being processes. We're not sure at this point, but it is certain that being able to interact with game-world objects in a natural way is a system requirement.</p>
    <p>Here we do not mean "objects" as in higher order functions that know how to dispatch, or structs that have better syntax for calling functions they contain pointers to, or whatever. Here I mean "game world things". A torch, a bit of grass, a delicious cheeseburger, a weapon, a pair of pink pants, etc. These are the objects of the game world. It is obvious that different object types exist, and that different rules must exist for different object interactions, at least to some degree. How should this be modeled?</p>
    <p>In a C-style game system objects are usually just structs that contain current information and a pointer to static, definition type information. So if the game system permits weapons to have declining durability, for example, the struct representing the weapon would maintain a record of its current "health" status, and a pointer to things like its max health, its effectiveness, offensive bonus, weight, and whatever else about it that might be significant but unchanged by its health status. Within this static information would be a record of its class type, usually something like an enum <code>{weapon, shield, armor, food, drink, ...}</code> and this would be checked against a list of permitted actions to enable the eating of a ham, but prevent wearing a ham as a helmet or wielding a rose as a weapon. Along with this sort of a system is usually an item -> slot sort of system that governs what types of items within the equipment class can be equipped where, and to represent within the mob model which slots are occupied this prevents having to check for things such as a player wear 10 sets of gauntlets at once and massively stacking up a huge armor bonus, for example.</p>
    <p>In Erlang we can opt to have objects in the game world be processes which track their own location and status (which can lead to hordes of processes sitting around for the chance to be interacted with), a directory of definitions and independent directory entries within whatever process contains them (leading to the classic "dupe" bug problem nearly every adventure-type game seems to suffer from at least once — how do you confirm that an object contained in the location has been removed from a mob or container inventory, for example?) or a hybrid approach. While we can know even at this early stage that some sort of process-based model that is not merely a global directory is probably best, we will leave the question of exact implementation and possible fear of an efficiency or resource problem open for now.</p>
    <p>It might seem strange to leave the question of whether potentially thousands of object processes sitting around in memory, maybe noisily messaging each other all the time will be a problem later on or not. In an OOP type system this might be rather hard to fix later on if not designed out of the system right now. Gobs of dependent calls will wind up buried all over the code that will be rather annoying to factor out later on. But I've found in my experiences with Erlang that its usually best to blithely assume that the "everything is a process" concept will work out fine (unless there is some really obvious reason it won't), and once a problem is encountered later after most of the system has been written and we actually have some hard performance data, that it is relatively easy to switch message routes around and replace the representation of a single component within even a relatively complex system. A big part of this has to do with the way we will encapsulate the data we are working with, and Erlang's refusal to let us share anything between processes helps prevent us from coding ourselves into a troublesome corner in this regard.</p>
    <h4 id="mobs">Mobs</h4>
    <p>Mobile entities (aka "mobs") are the focus of the game. Mobs are what do the verby things in MUDs. They are the world creatures, the NPCs, the player avatars, the predators and the prey. Without them the MUD would be a pretty boring place. Knowing that all the above types of characters and creatures which occur in MUDs are mobs indicates a few things. Namely, that while a general definition of mob may suffice, the controlling elements that make decisions for mobs may require a bit of diversification.</p>
    <p>Active things! This means every beast, player, NPC, demon, perpetually kidnapped princess or whatever else we decide to include in the game world that is alive falls into this category. Anything that is attackable, killable, aggressive, prone to flee, talk-to-able, able to break the law, able to enforce the law, able to join a faction, full of hate or love or duty, or have a relationship must be a mob. Without stuff like this the game world would be pretty boring.</p>
    <p>To perform actions mobs will have to know where to send messages that represent or initiate actions, be able to somehow observe their situation in a reliable way, maintain an inventory, know what state they are in (awake, sleeping, in combat), have some mechanism of determining the effects of received offensive and defensive actions balanced against ongoing effects that influence the impact of such received actions. This implies that mobs must have some mechanism for being spawned, being hurt, being healed, dying, and being respawned.</p>
    <p>But that is just life and death. The whole range of things that occurs between a mob's spawning and its death is what we are really interested in. How do mobs communicate? Not in the sense that their processes send messages to other processes, but within the semantics of the game world. Can a player's avatar talk to another player's avatar? How does this happen? Obviously mobs other than players are going to move around. Where are the decisions for the NPCs made? Within the mob model, in some global process that controls everything players aren't controlling, or by some other process? Critically for us as programmers, we have to find some design that makes the interface between mobs in general and other elements of the game world as perfect an abstraction as possible, so that the design of locations and objects will not have to take into account whether the mob processing sending it a message is an NPC, a player, or some other mobile entity. This is not terribly hard once we realize how important this form of abstraction is, but if we hadn't thought things through this far and simply sat down to write out the entire game system in one huge module we would quickly find ourselves in trouble.</p>
    <p>This idea that mobs must be abstracted from other elements of the game world, and that mobs must have some mechanism for making decisions brings up an interesting aspect of Erlang design. Let's consider the difference between an NPC and a player character. A player character is connected to a player across the network somehow and this player is making decisions in his mind and sending commands back to the mobs which it is acting upon. The NPC is somehow making decisions on its own. We can either design two completely different mob modules, one for NPCs and one for PCs, where the NPC contains some AI mechanism and the PC contains some network connection handling code. This requires we develop a strict protocol or interface definition among the game elements that are considered mobs, and adhere to it within the design of both NPCs and PCs. Locations and objects would have no way of knowing whether they are communicating with an NPC or a PC so long as the communication protocol perfectly abstracted the concept of mob. The other way of doing things is to design a generic mob concept which knows how to interact with the world and to accept commands (like the PC mob above, but without the network code), and then develop a "controller" sort of process which might be a "PC controller" type that knows how to talk to players and an "AI controller" type that knows how to make NPC decisions.</p>
    <p>Whatever we decide, it will have an impact on how development will go and how easy it is to change things around in the future. If we create two different mob types, then the protocol that both mob types must adhere to spans every point of interaction with every other game element. This is burdensome if we want to implement mounts, for example, because every place that relates to mount implementation will have to change across both the NPC and the PC code. in most code this is handled by slowly crippling the functionality of NPCs in favor of spending development effort on adding features to PCs. If, on the other hand, we develop a general mob process and then place a controller behind it, we can much more easily develop a flexible system. With such a design it would even be trivial to permit players to take over control of mobs in progress, or pass control of their characters to AI controllers in the middle of play instead of renting a room at an inn or simply idling out in space. This sort of design is not just better because it will ease our burden as programmers, but its better because it enhances the options for how the system can be made to behave.</p>
    <p>Controllers and mobs will be discussed in more detail later on</p>
    <h3 id="unseen">That which is unseen</h3>
    <p>In thinking through the three main elements of the MUD some indications that a three-module codebase was going to be insufficient. When discussing locations we mentioned that locations have quite a few more responsibilities than their imperatively implemented counterparts do, and while we're sure that locations will be required to handle some message broadcasting (notifications to everyone in the location), directory lookups (who or what is in the location), and respond to basic queries (give the room description, name, etc.), we left open the non-trivial question of how locations are to  be interconnected. When discussing objects and mobs a list of attribute descriptions was given for mobs, but not for objects. What objects can "do" (if they can do anything) and what mobs can do, and where some crossover may exist was never addressed. In particular, we never developed a concept for how a world object that is not a mob might behave. Ultimately, we have no idea about how to implement time-decaying foods, traps, or anything else of that nature. The trap case is discussed below as an example. The discussion about mobs also touched on a very important subject: the mob controllers. These issues, and any complications arising immediately from them, will be discussed in more detail below.</p>
    <h4 id="ways">Ways</h4>
    <p> In particular, the issue of how locations know its safe to permit a mob to depart to a certain adjacent location, how it knows the adjacent location's process is up, and how to handle the concept of open/closed/locked ways or doors to other locations has been left unaddressed, but that little sense programmers often have that something is not quite as simple as it seems on the surface is telling me that this area of functionality is both complex enough that it requires its own logic and orthogonal to the basic duties of a location to justify being placed in a separate module.</p>
    <h4 id="traps">Traps</h4>
    <p>At the beginning of the <a href="./001-001_concept.html#mobs">Mobs</a> section above I listed a series of descriptive qualities that mobs might have. Throwing out so many descriptions in terms of possible actions, adjectives and influences is useful to shape our thinking about the game world. For example, above I wrote "attack" but did not write "cast a spell". We should consider whether, for example, we want to include traps within the game world, and if so what sort of mechanism makes a trap work, and whether a trap is attacking, casting a spell, or acting on its victim by some entirely different mechanism. In short, we have to determine whether a trap is a "stationary mob", a mechanic governed by its hosting location, or some independent means that will require a new module that defines a trap as its own process. It is not particularly important at this stage whether we decide to include traps or not, but that we consider how to design a system in which traps are not impossibly difficult to implement.</p>
    <h4 id="controllers">Controllers</h4>
    <h2 id="thoughts">Thoughts on implementation</h2>
    <p>At this point we have a firm enough idea about how the primary <em>game</em> elements could be sketched out in pseudo code (or crayon, for that matter), but the elements of the<em>system</em> have not yet been addressed at all. How does the system start? What do we call? How do we contact it? Where do locations, objects and mobs come from in the first place?</p>
  </div>
  <div id="footer">
    <div id="nav"><a href="000-001_introduction.html">&lt; Previous</a></div>
    <div id="nav"><a href="index.html">Home</a></div>
    <div id="nav"><a href="001-001_concept.html">Next &gt;</a></div>
  </div>
</body>
</html>
