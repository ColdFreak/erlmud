<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" />
  <title>ErlMUD Commentary: Architecture - System Scaffolding | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="scaffolding">It's all scaffolding</h1>
    <p>The game we want to write is one thing, but just defining the game isn't enough. It must be written, debugged, checked for impossible situations (especially type mismatches), tested, built, distributed, executed, initialized by the host, given necessary resources, contacted by users, and about a hundred other things. None of those things are the game, though. The details of how we do those things are incidental to the fact we are writing a game in Erlang and we hope to be able to maintain it through an upgrade lifecycle (this isn't an exercise in abandonware!).</p>
    <p>The essential nature of what we are doing is writing a game platform, incidentally it must be written in some language and run on some platform. This remains true regardless what language or platform we choose. Incidentally, we chose Erlang/OTP. The language is Erlang and the platform is a suite of facilities OTP provides atop the Erlang VM.</p>
    <p>All that incidental stuff is central to what Erlang/OTP exists to help you do (especially the OTP part), but none of it is inherently game-related. This is all just scaffolding, and there are about as many ways to do it as there are programs. We're going to do things the na√Øve, raw Erlang way first and gradually migrate to the OTP way. The raw Erlang way is initially very simple to start out with, easy and fast to hack  experimental ideas with, and generally a ton of fun. Very cool. The problem we will encounter later is that handling the bazillion annoying things one encounters in production become tedious to deal with in raw Erlang. We would wind up basically re-writing OTP if we stick with raw Erlang to the end (but not as well, and with no support team behind us). There is a natural transition point where the programmatic complexity of handling the details of production issues in raw Erlang surpasses the mental overhead of learning something like OTP that manages those things for you.</p>
    <p>The previous two chapters discussed the initial design in terms of the game and its elements, but not in terms of an Erlang program and system components. In this chapter we will discuss the pieces necessary to interact with users and environment (things outside the Erlang world), implement a chat system (things within the Erlang world), and get our system started as a very simple Erlang program (get the Erlang world to go in the first place). Of all the parts of the code, the ones here are likely to undergo the most genuine structural change as ErlMUD matures, particularly the details of source organization and project structure.</p>
    <h2 id="network">Network interface</h2>
    <p>MUDs traditionally work over telnet and do not require any special client-side software. We will follow suit in ErlMUD, at least for a while. Using TCP sockets in Erlang is so simple that it is tempting to break with tradition and ditch telnet, develop a new TCP protocol and write our own client-server suite. But we're not going to do that, not right now. Telnet is easy, and easy is a good place to start.</p>
    <p>I'm pretty sure I can get the main MUD game elements to work without much fuss. I'm also pretty sure that if I mess around a bit I can write a telnet server module (should be a lot easier than it was in C and Pascal!). Writing the game bits and a telnet module is already a significant amount of work, and both are things I've never tried in Erlang. I don't want to add development of a new network protocol, a whole new application (the client), a client installer or package(s), and a distribution method to the TODO list until we have something worth connecting to. We're not even into the code yet. Remember, YAGNI.</p>
    <p>In the next chapter we will look at some basic network code that implements a question-response service over a telnet connection. Then we'll figure out a way to make it fit within a very basic server. For now we need to recognize that the networking code cannot go into the main program loop and it can't go inside the controllers, either. (You might think "duh!" but its amazing how often such structures occur in the wild.) That means we need to put it someplace on its own and think about it as a subordinate component in the overall system.</p>
    <p>So how should the network module work? It must listen for and accept connections over TCP. To handle several connections concurrently it must spawn a connection handler per connection and go back to waiting for new connections. The handlers should talk to controllers after doing some initialization or authentication stuff ("controller" as in last chapter's mob controllers). That's a pretty straightforward concept, abstract enough that it represents the way we would want pretty much any TCP network interface to work.</p>
    <p>It is up to us to establish what the contoller and connection will say to one another and use that as a template for any future connection-controller communication. If we step outside telnet someday all we have to do is make sure the shiny new Foo connection handler speaks the same protocol to the controller and we'll be fine.</p>
    <p>We will need the following networking bits:</p>
    <ul>
      <li>Telnet listener</li>
      <li>Connection handler</li>
      <li>Connection-controller protocol</li>
    </ul>
    <p>Not so bad. We will also have to figure out a way to plug this into the system without tying ourselves to telnet forever, but we can put that worry to sleep for a while by wrapping it in a warm, fuzzy function and singing it the abstraction lullaby.</p>
    <h3 id="listener">Telnet listener</h3>
    <p>The listener should be pretty simple. Just like a TCP listener in any other environment, it should grab a socket on a designated TCP port and listen (the telnet default is 23, but many MUDs run on custom ports). Once a new connection is made the listener should spawn another process to handle the connection and let it take control of whatever the new session's port is. Then it should loop back to listening and wait for another connection. That's it.</p>
    <p>If you've never written network code before, this is the essence of what TCP servers do, with all the gritty details in the middle cut out. If you're interested to see what goes on down below in C, <a href="http://beej.us/guide/bgnet/">Beej's Guide to Networking</a> is a decent primer for application and server developers. (Kernel and hardware networking code can get pretty insane, though.)</p>
    <h3 id="connection">Connection handler</h3>
    <p>The connection handler will be slightly more complicated than the listener. When the listener receives a new client it will establish a new TCP connection on an ephemeral port, spawn a connection handler and pass it the connection port. Once the connection handler has been spawned it should initiate whatever the authentication procedure is, send the initial welcome/login message to the client, and then wait for data.</p>
    <p>When the handler receives messages that represent TCP data it will put it into an aggregate collection, check if it was the end of a complete transmission and loop back to wait for more. If the data received indicates it is the end of a complete transmission (not the end of the session) it will have to assemble the data the client sent from the message aggregate and then process the received data before going back to check for more. If it receives an indication the TCP connection has ended it should close the port and kill itself.</p>
    <p>Telnet defines a way of identifying when a transmission is complete and TCP defines a way of telling us a connection has ended. Lucky for us, the Erlang standard library has a <a href="http://www.erlang.org/doc/man/gen_tcp.html">gen_tcp</a> module that makes dealing with the TCP parts really easy. It is up to us to make sure we write the telnet bits so they behave the way telnet clients expect. Fortunately telnet is also pretty simple.</p>
    <p>I hand-waved the "process the data" step above. This is where it can get a bit complicated. We have to decide if the handler will pass each raw transmission's payload off to another process for interpretation (parsing, tokenizing, figuring out the meaning of whatever the user typed), or call interpretation functions directly and send messages to the controller process. I'm inclined to call interpretation functions from within the handler directly, because we want to block the connection (TCP data will queue, so this is no big deal) if processing takes some time. Blocking like that prevents the incoming messages from getting out of phase with whatever is being processed, also, and that's a good thing. I'll probably split the telnet code bits from the MUD-specific bits (and wind up with independent MUD-connection and telnet libraries) but if the details are properly hidden behind the "network interface" abstraction I won't take an inordinate amount of time worrying about that early on.</p>
    <h3 id="protocol">Connection-Controller protocol</h3>
    <p>This can be easy and generic or hard and overloaded with rich features. I'm inclined to make it easy. Because we are doing two-way communication with the client we will need the connection handler to listen for outgoing TCP data in addition to incoming. In essence, the handler is the translation piece for the controller that represents the actual user session from the perspective of the server. Because we will always be receiving complete telnet messages from clients and always sending complete responses back, it is OK to have the initiation of a receive or a send message block the other direction until the transmission is complete. This should be easy because we have two levels of message data buffering working for us. The networking subsystem will maintain a queue of incoming TCP messages we can receive when we are ready, and the Erlang runtime maintains a similar queue of incoming Erlang messages for the handler process. When we receive outgoing data we can translate its payload in a single step and send it, and when we receive incoming data we can collect the entire message and then block until it is interpreted and send to the controller process.</p>
    <p>This means we will be primarily concerned with just two message types: incoming data and outgoing data. Because we want the controller and the handler to act as a single unit it is probably best to link them (remember, this means if one dies the other does as well). It is probably OK to make their communication asynchronous: they do not expect meaningful responses from one another, so there is no need to block either when sending a message. The only obvious purpose making the protocol between them synchronous would be to send acknowledgements of receipt, but this is not necessary since the Erlang runtime already guarantees delivery for us so long as the target process is alive.</p>
    <h2 id="chat">Chat system</h2>
    <p>So far this is the only user-facing element that is not arbitrated by locations. Chat is central to the purpose of MUDs so we can't dodge thinking about this early on.</p>
    <p>Each location is sort of its own little chat channel, since all verbal and emote activity is visible to other occupants. We might want to implement something like a "shout" feature, where any really loud action (like an actual shout) can be heard by all mobs within a zone or maybe N-locations away. What is similar and what is different between chatting on global channels, talking in a room, and shouting across a zone?</p>
    <p>Channels? Locations? Zones? Races? Factions? Hmmm. Let's break the underlying ideas down and see if we can identify some similarities; if we can there is a good chance we can prevent ourselves from duplicating a ton of code.</p>
    <p>We know that locations maintain a roster of mobs. Channels would have to do a similar thing, but maybe with controllers instead of mobs (and we'll leave this undetermined for now). In a sense, a location is a chat channel with a radically advanced set of extended features, but the basics of receiving an action that should be broadcast and performing the broadcast are the same. We know that zones would have to maintain an inventory of the locations from which it is composed. Assuming that races/homelands are a sub-element of factions (sort of like racial affiliation with a faction in World of Warcraft) then faction-wide channels might be an aggregation of racial channels. Obviously locations and zones have an impact on gameplay and chat doesn't, but the communication responsibilities of both are strikingly similar. In fact, the only real difference between the two so far is that gameplay messages definitely go to mobs, and chat might only go to controllers (which indicates there may be more to the concept of controllers than we've realized yet).</p>
    <p>We'll probably never fit communication and world simulation duties into the same module (or if we did, it wouldn't be a module I'd want to try reading), so I'll abandon that idea. It is quite likely, however, that with so many of the same procedures occurring we will find a way to abstract the basic pattern of communication channel operations and roster maintenance that we can create a library of common functions that all these modules call. This is the opportunity we need to stay alert to as we write location, chat, zone and channel code.</p>
    <p>Note that the above reads "stay alert to" instead of "commit to right now". We don't know what location or chat code looks like. Its almost certain that the first time around we'll do something wrong or silly when it comes to communication handling. This is one of those cases where we know we'll probably write the code once, get it to work, and then realize something we didn't notice before and rewrite the code better. We may as well do that in the course of writing the location and chat code instead of writing the same (bad) code twice, then fixing it twice in two places, and then extracting it into a library. I prefer to write code once in one module to get it to work, then write it in another module and see if I learn anything by comparing the two versions. Then I collapse the base idea within those modules to make it look the same, and then extract it, knowing for certain now that it is safe to do so.</p>
    <p>What about private messages, like "whisper" or "tell" features? Its easy enough to implement a "tell" that makes one mob send a tell directly to another mob, bypassing anything else. We can even say that each mob maintains its own "ignore" list and avoid having to write a central message nanny. I like this idea because it is simple, but we will have to decide if its better to have tells be a gameplay feature (handled by mobs and passed to controllers) or a system feature (handled by controllers directly). And that brings up the issue of targetting.</p>
    <p>We've never established what the global identity of a mob is. In a location I might target the first of a group of similar mobs by using a generic alias, but what if I want to target the third one in the group? This implies that there is an ordering to mobs in a location, another idea we've never dealt with. This is an issue I was hoping to avoid until we dealt with direct interaction (combat, trading, etc.) but if private messaging occurs at the mob level then it is clear we can't sidestep it. So instead I think we'll separate the idea of "tell" and the idea of "whisper". A tell will be direct chat message between controllers, and a whisper will be a direct game action between two mobs in the same location. This disambiguates the concept and allows us to be clear about which idea we mean, and it also allows us to continue to defer the gameplay concept until later.</p>
    <p>This leaves us with the issue of routing. In Erlang routing is pretty simple: send a message to some process and the runtime figures it out for you. But we want a chat system that has channels. Above we realized that chat channels are rather similar to locations in several ways. So we'll make channels their own processes, have them maintain a roster of participating controllers, and have the channel receive messages from participants and reflect them to every controller on the roster. Most everyone is familiar with basic IRC commands, so our system can mimic the behavior of basic ones like /join and /quit without getting too crazy.</p>
    <p>Many MUD systems have a factional chat system that is considered game related. If we add a layer of chat such as this it could work the same way, and even be based on the same code, but would have to work through mobs (and hence be sending messages not just to player controllers of a faction, but to AI controllers as well). I'm not going to mess with this yet, because I think its too gameplay involved and complex to spend any time on yet. But I don't want to forget the idea, so I'm documenting it here; later on it may inspire a cool feature or two.</p>
    <p>So that's the plan for now: first get a simple, global broadcast type chat working, and diversify from there based on whatever features we decide to implement later on. At first, anyway, with zero or very few players we won't really need to do much with channels, so we can keep in mind that we want to implement channels later on, but skip doing anything with that idea for now.</p>
    <p>It looks like we need:</p>
    <ul>
      <li>channels</li>
      <li>channel-controller protocol</li>
      <li>chat commands</li>
    </ul>
    <h3 id="channels">Channels</h3>
    <p>Turn me on.</p>
    <h3 id="chan_con">Channel-Controller Protocol</h3>
    <p>They talk.</p>
    <h3 id="chat_commands">Chat Commands</h3>
    <p>Lots of slashes and hashes and things. The terror of ASCII.</p>
    <h2 id="accounts">Accounts</h2>
    <p>People have to have some way of identifying themselves to the game server so that it can locate their character. Or not. We might want to design a game world where every time you log in you randomly inhabit a pre-existing mob and engage in whatever is going on nearby on your own. This is actually a pretty interesting idea, so I'll write it down, but for now I'm going to use the old-fashioned (and not very secure, but easy to implement) username/password way of doing things.</p>
    <p>But do players have accounts and characters, or is every character an account? We've found ourselves back at the issue of identity again, but from the direction of account management instead of chat and gameplay targetting. Obviously we have to do something about this. So what is an account? Its obviously different from a mob's identity, but is it different from a controller's identity? In most systems accounts are really just rows in a user table or file somewhere (consider /etc/passwd), and a token representing authority is granted to a connection and that connection really represents the user from the perspective of the system. Our sstem could work a similar way, but instead of the connection representing the user, the controller that connection spawns could. Accounts themselves, though, would still be entries in a user table or file somewhere.</p>
    <p>Mobs will certainly have some concept of points or level status or something, but is this different than an account system or is the character system itself all there is to the account system? I like the free feeling old MUDs give by making characters painless to create and totally independent of one another with no account system above this. On the other hand, players today are pretty used to the World of Warcraft account model where one account owns several characters. The problem there, of course, is that if your account gets compromised all your characters are compromised at once. Its a player-side version of putting all one's eggs in one basket, which is good to avoid. Perhaps a good middleground is possible, where we create an account system, where each account owns only one character, but make it possible to add additional characters later on, but just not implement the command functionality for that yet.That means we need player accounts, and they need to track what mobs they own.</p>
    <p>So that's two things to implement: a storage system for persistent character data (whatever the system remembers of you when you "rent" or logout), and an account storage system for tracking account/character relationships.</p>
    <h2 id="erlmud_start">erlmud:start/0</h2>
    <p>Any system needs a way to get started. Some folks write this module in as much detail as they can first, and then work from there down to the details. Some folks work on the tiny components first, assembling their code from little blocks as they go. I mostly do the top-down part, but don't spend much time on detail at the highest level. Instead I usually write a <code>somapp:start/0</code> function that barely suffices to spawn a unique process, and then revise from there as I go. I've decided that this prevents me wasting time on too much detail that I don't have any hope of understanding just yet. It also allows me to be lazy at the high level and geek out at whatever level of the problem interests me first, so long as I am diligent enough to fill in the execution path between <code>start</code> and whatever I'm working on.</p>
    <p>This is one place that it can be good to start trying to iron out the verbiage of your project very early on. Write your initialization bits in a way that deals with your major system components at the level of abstraction you want the rest of the world to. Starting this early on forces pushing details to other modules, particularly in the case of whatever data models are used to start up the system. The last thing we want is for whoever configures the system and might actually deal with some top-level component to have to know that object state is represented as a tuple of form X underneath. Yuk.</p>
    <p>I'm going to leave this one wide open for now, and only implement a direct code path that spins up the application and phrase things in the initialization procedure in a way I think is natural. It will probably be wrong, or at least not look much like whatever the production version of this module will look like, but that's OK for now.</p>
    <h1 id="thoughts">Parting Thoughts</h1>
    <p>At this point we have a pretty solid idea what the different system components are and what they should do, or at least what we think we do. The only way to tell if our architecture makes sense is to try sketching it out in code. In the next section we'll start implementing very simple versions of each of these pieces in an order I think is reasonable, and add code a bit at a time until we have a very basic MUD engine in place. Keep in mind we're not aiming at a full implementation of any particular style of gameplay yet; if we get this groundwork part right the gameplay will be easier to focus on because we will be able to (mostly) assume the world works as we expect.</p>
    <p>It might seem strange to leave unaddressed the question of whether hordes of processes (potentially tens of thousands) sitting around in memory incessantly messaging each other will be a problem later on or not. With Erlang I've found it best to blithely assume that the "everything is a process" concept will work out fine (unless there is some really obvious reason it won't), and that tittering over performance concerns before any hard data is available is a waste of time. Actually, its worse than that: it invites all sorts of ridiculous structural "optimization" ideas at the proto-architecture stage of design (the part where you're musing out the window, thinking, without having done so much as type <code>git init</code>). Early assumptions made before any code has been written tend to doom the resulting project with a cancerous affliction of radically un-idiomatic Erlang antipatterns. It is relatively easy to switch message routes around and replace the representation of components within even a relatively complex system. It is usually not as easy to move the execution point of large chunks of interdependent logic from a single monolithic process to a pool of workers, though (and part of the problem can simply be emotional investment in a "hard" part of code by the developer). Until we can generate some hard performance numbers we have to trust that Erlang's concept of per-process encapsulation, strict message passing (basically the "actor model") will work in our favor and go with the flow.</p>
  </div>
  <div id="footer">
    <div id="nav"><a href="001-002_architecture.html">&lt; Previous</a></div>
    <div id="nav"><a href="index.html">Home</a></div>
    <div id="nav"><a href="001-003_architecture.html">Next &gt;</a></div>
  </div>
</body>
</html>