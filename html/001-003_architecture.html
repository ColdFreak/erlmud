<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" />
  <title>ErlMUD Commentary: Architecture - System Scaffolding | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="scaffolding">It's all scaffolding</h1>
    <p>The game we want to write is one thing, but just defining the game isn't enough. It must be written, debugged, checked for impossible situations (especially type mismatches), tested, built, distributed, executed, initialized by the host, placed in charge of some system resources, contacted by users, and about a hundred other things. None of those things are the game, though. It is all incidental to the fact we are writing a game in Erlang and we hope to be able to maintain it through an upgrade lifecycle (we're not practicing to write abandonware). The essential nature of what we are doing is writing a game, and that would remain the same in any language on any platform.</p>
    <p>All that incidental stuff is central to what Erlang/OTP exists to help you do (especially the OTP part), but absolutely none of it is inherently game-related. This is all just scaffolding, and there are about as many ways to do it as there are programs. We're going to do things the na√Øve way first and gradually migrate to the OTP way.</p>
    <p>The previous two chapters discussed the initial design in terms of the game and its elements, but not in terms of an Erlang program and system components. In this chapter we will discuss the pieces necessary to interact with users and environment (things outside the Erlang world), implement a chat system (things within the Erlang world), and get our system started as a very simple Erlang program (get the Erlang world to go in the first place). Of all the parts of the code, the ones here are likely to undergo the most genuine structural change as ErlMUD matures, particularly the parts about source organization and project structure.</p>
    <h2 id="network">Network interface</h2>
    <p>MUDs traditionally work over telnet and do not require any special client-side software. We will follow suit in ErlMUD, at least for a while. Using TCP sockets is easy enough in Erlang that its tempting to break with tradition and develop a new TCP protocol and write our own client-server suite for both ends. But we're not going to do that, at least not right now. Telnet is easy, and easy is a good place to start.</p>
    <p>I'm pretty sure I can get the main MUD game elements to work without much fuss. I'm also pretty sure that if I mess around a bit I can write a telnet server module (should be a lot easier than it was in C and Pascal!). Writing the game bits and a telnet module is already a significant amount of work, and both are things I've never tried in Erlang. I don't want to add development of a new network protocol, a whole new application (the client), a client installer or package(s), and a distribution method to the TODO list until we have something worth connecting to. We're not even into the code yet. Remember, YAGNI.</p>
    <p>In the next chapter we will look at some basic network code that implements a question-response service over a telnet connection. Then we'll figure out a way to make it fit within a very basic server. For now we need to understand two things: the networking code cannot go into the main program loop, and it can't go inside the controllers, either. (You might think "duh!" but its amazing how often such structures occur in the wild.)</p>
    <p>We need to listen for and accept connections over TCP. To handle several connections concurrently we must spawn a connection handler per connection and have it talk to a controller ("controller" as in last chapter's mob controllers). We also need to establish what the contoller and connection will say to one another and use that as a template for any future connection-controller communication. If we step outside telnet someday all we have to do is make sure the shiny new Foo connection handler speaks the same protocol to the controller and we'll be fine.</p>
    <p>It seems we need the following networking bits:</p>
    <ul>
      <li>Telnet listener</li>
      <li>Connection handler</li>
      <li>Connection-controller protocol</li>
    </ul>
    <p>Not so bad. We will also have to figure out a way to plug this into the system without tying ourselves to telnet forever, but we can put that worry to sleep for a while by wrapping it in a warm, fuzzy function and singing it the abstraction lullaby.</p>
    <h3 id="listener">Telnet listener</h3>
    <p>The listener should be pretty simple. Just like a TCP listener in any other environment, it should grab a socket on a designated TCP port and listen (the telnet default is 23, but many MUDs run on custom ports). Once a new connection is made the listener should spawn another process to handle the connection and let it take control of whatever the new session's port is. Then it should loop back to listening and wait for another connection. That's it.</p>
    <p>If you've never written network code before, this is the essence of what TCP servers do, with all the gritty details in the middle cut out. If you're interested to see what goes on down below in C, <a href="http://beej.us/guide/bgnet/">Beej's Guide to Networking</a> is a decent primer for application and server developers. (Kernel and hardware networking code can get pretty insane, though.)</p>
    <h3 id="connection">Connection handler</h3>
    <p>The connection handler should be pretty straightforward as well. When the listener receives a new client it will establish a new TCP connection on an ephemeral port (in this case "ephemeral" usually means "random, high-number, in use only for the duration of the connection), spawn a connection handler and give it the connection port. Once the connection handler has been spawned it should initiate whatever the authentication procedure is, send the initial welcome/login message to the client, and then wait for data.</p>
    <p>Receiving data is slightly more complicated than just receiving connections. The handler must wait for data, and when it receives it process the data and loop back to wait for more. If the data received indicates it is the end of a complete transmission (but not the end of the session) it will have to process the received data before going back to check for more. If it receives an indication the TCP connection has ended it should close the port and kill itself.</p>
    <p>Telnet defines a way of identifying when a transmission is complete and TCP defines a way of telling us a connection has ended. Lucky for us, the Erlang standard library has a <a href="http://www.erlang.org/doc/man/gen_tcp.html">gen_tcp</a> module that makes dealing with the TCP parts really easy. It is up to us to make sure we write the telnet bits so they behave the way telnet clients expect. Fortunately telnet is also pretty simple.</p>
    <p>I hand-waved away the "process the data" step above. This is where it can get a bit complicated. We have to decide if the handler will pass each raw transmission's payload off to another process for interpretation (parsing, tokenizing, figuring out the meaning of whatever the user typed), or call interpretation functions directly and send messages to the controller process. I'm inclined to call interpretation functions from within the handler directly, because we want to block the connection (TCP data will queue, so this is no big deal) if processing takes some time. Blocking like that prevents the incoming messages from getting out of phase with whatever is being processed, also, and that's a good thing.</p>
    <h3 id="protocol">Connection-Controller protocol</h3>
    <p>This can be made easy or hard. I'm inclined to make it easy. Because we are doing two-way communication with the client we will need the connection handler to listen for outgoing TCP data in addition to incoming. In essence, the handler is the translation piece for the controller that represents the actual user session from the perspective of the server. Because we will always be receiving complete telnet messages from clients and always sending complete responses back, it is most sensible to have the initiation of a receive or a send message block the other direction until the transmission is complete. This should be easy to write because we have two levels of message data buffering working for us. The networking subsystem will maintain a queue of incoming TCP messages and we can receive them in order, even if we have to ignore them while the handler is working on something else. The Erlang runtime also maintains a queue of incoming Erlang messages to the handler process itself that works much in the same way. When we receive outgoing data we can translate its payload in a single step and send it, and when we receive incoming data we can collect the entire message and then block until it is interpreted and send to the controller process.</p>
    <p>This means we will be primarily concerned with just two message types: incoming data and outgoing data. Because we want the controller and the handler to act as a single unit it is probably best to link them (remember, this means if one dies the other does as well). It is probably OK to make their communication asynchronous: they do not expect meaningful responses from one another, so there is no need to block either when sending a message. The only obvious purpose making the protocol between them synchronous would be to send acknowledgements of receipt, but this is not necessary since the Erlang runtime already guarantees delivery for us so long as the target process is alive.</p>
    <h2 id="chat">Chat system</h2>
    <p>So far this is our only system element that is not arbitrated by locations and is globally accessible to users. Chat is not optional so we can't dodge thinking about this early on.</p>
    <p>Each location is sort of its own little chat server, since all verbal and emote activity is visible to other occupants. We might want to implement something like a "shout" feature, where any really loud action (like an actual shout) can be heard by all mobs within a zone or maybe N-locations away. We might also want to mimic a cool feature of WoTMUD where players of two different species can only understand their own kind in talk/shout communication, global game channels are segregated by race or faction, and only purely social chat channels are actually global (oddly, this feature is well received in WoTMUD and has been implemented for a few decades, yet halfhearted attempts at this never met with much success in graphical MUDs or MMORPGs). What is similar and what is different between chatting on global channels, talking in a room, and shouting across a zone?</p>
    <p>Channels? Locations? Zones? Races? Factions? Hmmm. Let's break the underlying ideas down and see if we can identify some similarities; if we can there is a good chance we can prevent ourselves from duplicating a ton of code.</p>
    <p>We know that locations maintain a roster of mobs present. Channels would have to do the same thing. In a sense, a location is a radically advanced form of channel, but the basics of receiving an action that should be broadcast and performing the broadcast are the same. We know that zones would have to maintain an inventory of the locations from which it is composed. Assuming that races/homelands are a sub-element of factions (sort of like racial affiliation with a faction in World of Warcraft) then faction-wide channels might be an aggregation of racial channels. Obviously locations and zones have an impact on gameplay and chat doesn't, but the communication responsibilities of both are strikingly similar.</p>
    <p>The above is all about similarities among elements that reflect or broadcast communication from the outside perspective of us as developers. What is similar from the perspective of the mobs that actually receive this communication? Its all just receipt of asynchronous messages. Nothing more. That makes things a lot easier to deal with. One side of communication is as simple as receiving a particular style of message, leaving all the complicated parts on the sending side. This is actually a really useful insight.</p>
    <p>We'll probably never fit communication and world simulation duties into the same module (or if we did, it wouldn't be a module I'd want to try reading), so I'll abandon that idea. It is quite likely, however, that with so many of the same procedures occurring we will find a way to abstract the basic pattern of communication channel operations and roster maintenance that we can create a library of common functions that all these modules call. This is the opportunity we need to stay alert to as we write location, chat, zone and channel code.</p>
    <p>Note that the above reads "stay alert to" instead of "commit to right now". We don't know what location or chat code looks like. Its almost certain that the first time around we'll do something wrong or silly when it comes to communication handling. This is one of those cases where we know we'll probably write the code once, get it to work, and then realize something we didn't notice before and rewrite the code better. We may as well do that in the course of writing the location and chat code instead of writing the same (bad) code twice, then fixing it twice in two places, and then extracting it into a library. I prefer to write code once in one module to get it to work, then write it in another module and see if I learn anything by comparing the two versions. Then I collapse the base idea within those modules to make it look the same, and then extract it, knowing for certain now that it is safe to do so.</p>
    <p>Another issue is whether a mob joins a channel, a controller joins a channel or a player's connection handler farther up the stack joins the channel (and is the player's connection the same as the controller?). Previously we had established that mobs require controllers and that separating controlling logic/interfaces and the mobs themselves is probably a good idea. Now we come to the question of "what part of a mob has ears and eyes?". I think it makes the most sense to give the mobs themselves the sensory organs, route chat messages along to the controller the same way other observations are, and let the controllers handle or disregard messages as needed. Then I can avoid writing any special case code into "chat listeners".</p>
    <p>What about private messages, like "whisper" or "tell" features? Its easy enough to implement a "tell" that makes one mob send a chat message directly to another mob, bypassing anything else. We can even say that each mob maintains its own "ignore" list and avoid having to write a central nanny message arbitration function. But this issue with ignores, private messages, channels, listening for shouts, emotes, verbals, etc. is already demonstrating that chat is actually not such a simple part of the game, simply because targetting, routing, listening and filtering are all issues we start having to suddenly deal with.</p>
    <p>Actually, I don't want to put this into the mob's core logic. I really want to just have a single message tag, like <code>{chat, From, Message}</code> and have <code>Message</code> contain the message itself and a meta message that we can perform filter, routing, etc. logic on. And I don't want to write that logic into the actual mob processes themselves, because I'm pretty sure the metabolism and combat system is going to fill quite enough lines of code as it is. So we should write a second, assistance module for mobs that behaves like their sensory organ. Chats can either target that directly, or target the mob and the mob pass its message into it asynchronously (this is the kind of process I would link, so its logically a part of the mob, and if either crashes the whole mob crashes), and the sensory process can take over from there.</p>
    <p>We need to write a system of channels which can be created, joined, left, and moderated. This will probably look a bit like the way locations are implemented, but without all the extra logic of physical arbitration, travel, or anything else hard. We don't need a map, either, but we may want to define some boundary conditions for chat channels, like default instantiation of factional or race-based chat rooms or something of that sort. To begin with, though, we should probably aim low and write a single global chat channel, then once we understand that, add another, and then add an in-game way to identify who should automatically belong to faction-type channels, and make a way for players to create channels in-game as well.</p>
    <p>So that's the plan for now: first get a simple, global broadcast type chat working, and diversify from there based on whatever features we decide to implement later on. At first, anyway, with zero or very few players we won't really need to do much with channels, so we can keep in mind that we want to implement channels later on, but skip doing anything with that idea for now.</p>
    <h2 id="accounts">Accounts</h2>
    <p>People have to have some way of identifying themselves to the game server so that it can locate their character. Or not. We might want to design a game world where every time you log in you randomly inhabit a pre-existing mob and engage in whatever is going on nearby on your own. This is actually a pretty interesting idea, so I'll write it down, but for now I'm going to do the old-fashioned (and not very secure) username/password way of doing things.</p>
    <p>But do players have accounts and characters, or is every character an account? Mobs will certainly have some concept of points or level status or something, but is this different than an account system or is the character system itself all there is to the account system? I like the free feeling old MUDs give by making characters painless to create and totally independent of one another with no account system above this. On the other hand, players today are pretty used to the World of Warcraft account model where one account owns several characters. The problem there, of course, is that if your account gets compromised all your characters are compromised at once. Its a player-side version of putting all one's eggs in one basket, which is good to avoid. Perhaps a good middleground is possible, where we create an account system, where each account owns only one character, but make it possible to add additional characters later on, but just not implement the command functionality for that yet.That means we need player accounts, and they need to track what mobs they own.</p>
    <p>So that's two things to implement: a storage system for persistent character data (whatever the system remembers of you when you "rent" or logout), and an account storage system for tracking account/character relationships.</p>
    <h2 id="erlmud_start">erlmud:start/0</h2>
    <p>Any system needs a way to get started. Some folks write this module in as much detail as they can first, and then work from there down to the details. Some folks work on the tiny components first, assembling their code from little blocks as they go. I mostly do the top-down part, but don't spend much time on detail at the highest level. Instead I usually write a <code>somapp:start/0</code> function that barely suffices to spawn a unique process, and then revise from there as I go. I've decided that this prevents me wasting time on too much detail that I don't have any hope of understanding just yet. It also allows me to be lazy at the high level and geek out at whatever level of the problem interests me first, so long as I am diligent enough to fill in the execution path between <code>start</code> and whatever I'm working on.</p>
    <p>This is one place that it can be good to start trying to iron out the verbiage of your project very early on. Write your initialization bits in a way that deals with your major system components at the level of abstraction you want the rest of the world to. Starting this early on forces pushing details to other modules, particularly in the case of whatever data models are used to start up the system. The last thing we want is for whoever configures the system and might actually deal with some top-level component to have to know that object state is represented as a tuple of form X underneath. Yuk.</p>
    <p>I'm going to leave this one wide open for now, and only implement a direct code path that spins up the application and phrase things in the initialization procedure in a way I think is natural. It will probably be wrong, or at least not look much like whatever the production version of this module will look like, but that's OK for now.</p>
    <h1 id="thoughts">Parting Thoughts</h1>
    <p>At this point we have a pretty solid idea what the different system components are and what they should do, or at least what we think we do. The only way to tell if our architecture makes sense is to try sketching it out in code. In the next section we'll start implementing very simple versions of each of these pieces in an order I think is reasonable, and add code a bit at a time until we have a very basic MUD engine in place. Keep in mind we're not aiming at a full implementation of any particular style of gameplay yet; if we get this groundwork part right the gameplay will be easier to focus on because we will be able to (mostly) assume the world works as we expect.</p>
    <p>It might seem strange to leave unaddressed the question of whether hordes of processes (potentially tens of thousands) sitting around in memory incessantly messaging each other will be a problem later on or not. With Erlang I've found it best to blithely assume that the "everything is a process" concept will work out fine (unless there is some really obvious reason it won't), and that tittering over performance concerns before any hard data is available is a waste of time. Actually, its worse than that: it invites all sorts of ridiculous structural "optimization" ideas at the proto-architecture stage of design (the part where you're musing out the window, thinking, without having done so much as type <code>git init</code>). Early assumptions made before any code has been written tend to doom the resulting project with a cancerous affliction of radically un-idiomatic Erlang antipatterns. It is relatively easy to switch message routes around and replace the representation of components within even a relatively complex system. It is usually not as easy to move the execution point of large chunks of interdependent logic from a single monolithic process to a pool of workers, though (and part of the problem can simply be emotional investment in a "hard" part of code by the developer). Until we can generate some hard performance numbers we have to trust that Erlang's concept of per-process encapsulation, strict message passing (basically the "actor model") will work in our favor and go with the flow.</p>
  </div>
  <div id="footer">
    <div id="nav"><a href="001-002_architecture.html">&lt; Previous</a></div>
    <div id="nav"><a href="index.html">Home</a></div>
    <div id="nav"><a href="001-003_architecture.html">Next &gt;</a></div>
  </div>
</body>
</html>