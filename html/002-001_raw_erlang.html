<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
  <meta name="author" content="Craig Everett">
  <meta name="copyright" content="&copy;2014 Craig Everett">
  <link rel="stylesheet" type="text/css" href="erlmud_s.css" />
  <title>ErlMUD Commentary: Raw Erlang - Forming a Skeleton | zxq9.com</title>
</head>
<body>
  <div id="header">
    <div id="title">
      <h1>ErlMUD Commentary</h1>
    </div>
    <div id="menu">
      <a href="index.html" title="Table of Contents">Home</a>
      <a href="https://github.com/zxq9/erlmud" title="Source on GitHub">Source</a>
      <a href="http://zxq9.com" title="zxq9's Home">zxq9</a>
    </div>
  </div>
  <div id="body">
    <h1 id="begin">Begin at the Beginning</h1>
    <p>Taking the Mad Hatter's advice, we will begin at the beginning. All I'm interested in is a bare-bones template that spawns a registered erlang process, executes an init function, and responds to messages in a loop. It may be emotionally simple, but its a good feeling to start with something that already talks back, even if the chatter is pointless to begin with.</p>
    <div class="source">
    <a href="https://github.com/zxq9/erlmud/blob/d61149ca4c5773d0223a9e70d0061db3b804f19b/erlmud-0.1/erlmud.erl">erlmud-0.1/erlmud.erl</a>
<pre>
 1  -module(erlmud).
 2  -export([start/0]).
 3
 4  start() ->
 5      register(erlmud, spawn(fun() -> init() end)).
 6
 7  init() ->
 8      io:format("~p erlmud: Starting up.", [self()]),
 9      loop().
10
11  loop() ->
12    receive
13      shutdown ->
14          io:format("~p erlmud: Shutting down.~n", [self()]),
15          exit(shutdown);
16      Any ->
17          io:format("~p erlmud: Received~n~n~tp~n~n", [self(), Any]),
18          loop()
19    end.
</pre>
    </div>
    <p>And playing with that in the shell...</p>
    <div class="terminal">
<pre>
1&gt; c(erlmud).
{ok,erlmud}
2&gt; erlmud:start().
&lt;0.40.0&gt; erlmud: Starting up.
true
3&gt; erlmud ! "something".
&lt;0.40.0&gt; erlmud: Received

"something"

"something"
4&gt; erlmud ! {message, "Some message."}.
&lt;0.40.0&gt; erlmud: Received

{message,"Some message."}

{message,"Some message."}
5&gt; erlmud ! shutdown.
&lt;0.40.0&gt; erlmud: Shutting down.
shutdown
</pre>
    </div>
    <p>From here I'll put stubs in for the system components and game elements identified in the last section, but just as stubs and nothing more. What I'm really looking for here is to force myself to think through system dependencies and identify if anything is obviously out of order, or if order even matters. (protip: If we can design the pieces so that startup order doesn't matter at all our life will be much easier. This is almost always impossible to achieve 100% if the supervisors are a tree, though, so there will always be some compromise.)</p>
<!--
    <p>Our initial goal will be to create some very basic components that conform to the main elements of the game platform as described above: locations, objects and mobs. As mentioned, will need a way to start the system up, a way to manager for each type of element that will probably evolve into a supervisor or supervision tree, and a few other elements. But we won't really care about that stuff to begin with. Our first goal is to simply create a 3-part system that can behave as a very basic game platform. We don't care about gameplay mechanics yet, we don't care what the world looks like right now, and we don't care that the only thing we can do in the world is move around, talk, emote, chat, and pick things up and put things down. Until we create a general basis for the world's most basic mechanics thinking too much about anything else is pipedreaming, and while exploring the system you ultimately want to build in your mind can help you come up with good ideas, too much of that without enough actual code to back it up leads to wasted time and premature project death.</p>

    <p>but we've deferred every element of the supporting system except the initiating function, <code>erlmud:start/0</code>.</p>
    <p>That's actually OK. The first thing I want to do is essentially get ErlMUD to a tree of "Hello, World!" programs anyway, and then work on the lower level components a little at a time, very gradually adding code until we actually have something like a world simulator that we can feed a map description and watch populate some locations and their ways. So we're going to write the path from erlmud:start/0 to the location manager, and the location manager to starting up whatever location definitions we tell it and make sure that happens first. We can't really do anything without locations anyway, so there we are.</p>
    <p> The first three elements form the basis for the game itself and the second three form the basis for user interaction with that system. While the above is a nice early enumeration of the outer pieces we want to build, this tells us nothing about how they should be created, managed, found, communicated with, or really anything else about the system.</p>
    <p>In terms of an Erlang program this is actually OK. With just this limited definition we can begin to explore the problem space in more depth. First we will think through the basic problem of how to model everything as processes, and simply assume that this is a reasonable approach. Then we will consider the problem of how to initialize these processes and have them communicate. We will make these ideas concrete by writing some elementary wishful-thinking code that describes the ideas in more detail, and go as far as making some of that code actually work in some very limited way.</p>
    <p>I usually find it useful to begin modeling a system as if everything were a process, and not really worrying much about data structures until I have a reason to. If we abstract our data and communication methods properly, changing things like that in the background are typically not too much trouble. A surprising amount of the time any nagging performance worries we might have about having "too many" processes turn out to have been unfounded, or even contrary to high performance in a massively parallel environment. With more processes it is easier to scale "out" and not "up". This is an early part of removing bottlenecks by never creating any.</p>
-->
  </div>
  <div id="footer">
    <div id="nav"><a href="001-003_architecture.html">&lt; Previous</a></div>
    <div id="nav"><a href="index.html">Home</a></div>
    <div id="nav"><a href="002-001_raw_erlang.html">Next &gt;</a></div>
  </div>
</body>
</html>
